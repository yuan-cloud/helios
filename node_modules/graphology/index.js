export default class Graph {
  constructor(options = {}) {
    this.options = { ...options };
    this.nodeAttributes = new Map();
    this.directedEdges = new Map();
    this.undirectedEdges = new Map();
    this.inAdj = new Map();
    this.outAdj = new Map();
    this.undirectedAdj = new Map();
  }

  addNode(id, attributes = {}) {
    if (!this.nodeAttributes.has(id)) {
      this.nodeAttributes.set(id, { ...attributes });
    }
  }

  hasNode(id) {
    return this.nodeAttributes.has(id);
  }

  getNodeAttribute(id, key) {
    const attrs = this.nodeAttributes.get(id);
    if (!attrs) return undefined;
    return attrs[key];
  }

  setNodeAttribute(id, key, value) {
    const attrs = this.nodeAttributes.get(id) || {};
    attrs[key] = value;
    this.nodeAttributes.set(id, attrs);
  }

  mergeDirectedEdgeWithKey(key, source, target, attributes = {}) {
    this.directedEdges.set(key, { source, target, attributes: { ...attributes } });
    this._ensureNode(source);
    this._ensureNode(target);
    this._addToAdjacency(this.outAdj, source, target);
    this._addToAdjacency(this.inAdj, target, source);
  }

  mergeUndirectedEdgeWithKey(key, source, target, attributes = {}) {
    this.undirectedEdges.set(key, { source, target, attributes: { ...attributes } });
    this._ensureNode(source);
    this._ensureNode(target);
    this._addToAdjacency(this.undirectedAdj, source, target);
    this._addToAdjacency(this.undirectedAdj, target, source);
  }

  nodes() {
    return Array.from(this.nodeAttributes.keys());
  }

  forEachNode(callback) {
    this.nodeAttributes.forEach((attrs, id) => {
      callback(id, attrs);
    });
  }

  forEachEdge(callback) {
    this.directedEdges.forEach((edge, key) => {
      callback(
        key,
        edge.attributes,
        edge.source,
        edge.target,
        this.nodeAttributes.get(edge.source) || {},
        this.nodeAttributes.get(edge.target) || {},
        false
      );
    });
    this.undirectedEdges.forEach((edge, key) => {
      callback(
        key,
        edge.attributes,
        edge.source,
        edge.target,
        this.nodeAttributes.get(edge.source) || {},
        this.nodeAttributes.get(edge.target) || {},
        true
      );
    });
  }

  forEachNeighbor(node, callback) {
    const seen = new Set();

    const processNeighbors = (adjMap, n) => {
      const neighbors = adjMap.get(n);
      if (!neighbors) return;
      neighbors.forEach(neighbor => {
        if (seen.has(neighbor)) return;
        seen.add(neighbor);
        callback(neighbor);
      });
    };

    processNeighbors(this.outAdj, node);
    processNeighbors(this.inAdj, node);
    processNeighbors(this.undirectedAdj, node);
  }

  inDegree(node) {
    return this._degreeFromMap(this.inAdj, node);
  }

  outDegree(node) {
    return this._degreeFromMap(this.outAdj, node);
  }

  undirectedDegree(node) {
    return this._degreeFromMap(this.undirectedAdj, node);
  }

  _ensureNode(id) {
    if (!this.nodeAttributes.has(id)) {
      this.nodeAttributes.set(id, {});
    }
  }

  _addToAdjacency(map, key, value) {
    if (!map.has(key)) {
      map.set(key, new Set());
    }
    map.get(key).add(value);
  }

  _degreeFromMap(map, node) {
    const set = map.get(node);
    return set ? set.size : 0;
  }
}


