<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HELIOS - See the gravity of your code</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700;800&display=swap" rel="stylesheet">
    <!-- COI Service Worker - Must be first script to enable SharedArrayBuffer and OPFS -->
    <script src="/coi-serviceworker.js"></script>
    <script type="importmap">
    {
      "imports": {
          "web-tree-sitter": "/public/vendor/tree-sitter.js",
          "3d-force-graph": "/public/vendor/3d-force-graph/3d-force-graph.mjs",
          "@xenova/transformers": "/public/vendor/transformers.min.js",
          "graphology": "/public/vendor/graphology/graphology.esm.js",
          "graphology-communities-louvain": "/public/vendor/graphology-communities-louvain/index.js",
          "three": "https://cdn.jsdelivr.net/npm/three@0.168.0/build/three.module.js",
          "three/examples/jsm/": "https://cdn.jsdelivr.net/npm/three@0.168.0/examples/jsm/",
          "three-forcegraph": "https://cdn.jsdelivr.net/npm/three-forcegraph@1.43.0/dist/three-forcegraph.mjs",
          "three-render-objects": "https://cdn.jsdelivr.net/npm/three-render-objects@1.40.4/dist/three-render-objects.mjs",
          "accessor-fn": "https://cdn.jsdelivr.net/npm/accessor-fn@1.5.3/dist/accessor-fn.esm.js",
          "kapsule": "https://cdn.jsdelivr.net/npm/kapsule@1.16.3/dist/kapsule.esm.js"
      }
    }
    </script>
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 64 64'%3E%3Cdefs%3E%3CradialGradient id='g' cx='50%25' cy='50%25' r='50%25'%3E%3Cstop offset='0%25' stop-color='%23a855f7'/%3E%3Cstop offset='55%25' stop-color='%236366f1'/%3E%3Cstop offset='100%25' stop-color='%230a0e27'/%3E%3C/radialGradient%3E%3C/defs%3E%3Ccircle cx='32' cy='32' r='30' fill='url(%23g)'/%3E%3C/svg%3E">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/themes/prism-tomorrow.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/prism.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-typescript.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-jsx.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-tsx.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-python.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: linear-gradient(135deg, #0a0e27 0%, #1a1a3e 25%, #2d1b4e 50%, #1a1a3e 75%, #0a0e27 100%);
            background-size: 400% 400%;
            animation: gradientShift 15s ease infinite;
            min-height: 100vh;
            overflow-x: hidden;
            overflow-y: auto;
            position: relative;
        }

        @keyframes gradientShift {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }

        .stars,
        .gravity-particles {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        .stars {
            z-index: 1;
        }

        .gravity-particles {
            z-index: 2;
        }

        .star {
            position: absolute;
            width: 2px;
            height: 2px;
            background: white;
            border-radius: 50%;
            opacity: 0.6;
            animation: twinkle 3s ease-in-out infinite;
        }

        .star:nth-child(odd) { animation-duration: 2s; }
        .star:nth-child(3n) { animation-duration: 4s; opacity: 0.4; }

        @keyframes twinkle {
            0%, 100% { opacity: 0.3; transform: scale(1); }
            50% { opacity: 0.9; transform: scale(1.2); }
        }

        .gravity-particle {
            position: absolute;
            width: 1px;
            height: 1px;
            background: rgba(199, 210, 254, 0.3);
            border-radius: 50%;
            animation: orbit 20s linear infinite;
        }

        .gravity-particle:nth-child(1) { top: 20%; left: 10%; animation-duration: 25s; }
        .gravity-particle:nth-child(2) { top: 60%; left: 80%; animation-duration: 30s; animation-delay: -5s; }
        .gravity-particle:nth-child(3) { top: 80%; left: 20%; animation-duration: 35s; animation-delay: -10s; }

        @keyframes orbit {
            0% { transform: rotate(0deg) translateX(100px) rotate(0deg); }
            100% { transform: rotate(360deg) translateX(100px) rotate(-360deg); }
        }

        @keyframes fadeInUp {
            from { opacity: 0; transform: translateY(30px); }
            to { opacity: 1; transform: translateY(0); }
        }

        @keyframes float {
            0%, 100% { transform: translateY(0px); }
            50% { transform: translateY(-20px); }
        }

        .hero-container {
            position: relative;
            z-index: 5;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 4rem 1.5rem;
        }

        .title {
            font-weight: 800;
            font-size: clamp(3.5rem, 10vw, 6rem);
            letter-spacing: -0.02em;
            background: linear-gradient(135deg, #ffffff 0%, #e0e7ff 50%, #c7d2fe 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-shadow: 0 0 40px rgba(199, 210, 254, 0.3),
                         0 0 80px rgba(199, 210, 254, 0.2),
                         0 0 120px rgba(199, 210, 254, 0.1);
            animation: fadeInUp 1s ease-out, float 6s ease-in-out infinite;
            margin-bottom: 1rem;
            opacity: 1 !important;
            visibility: visible !important;
            /* Fallback if gradient text doesn't work */
            color: #e0e7ff !important;
        }

        .tagline {
            font-weight: 300;
            font-size: clamp(1.125rem, 2.5vw, 1.5rem);
            color: #a5b4fc !important;
            letter-spacing: 0.05em;
            opacity: 1 !important;
            animation: fadeInUp 1s ease-out 0.4s forwards;
            margin-bottom: 3rem;
            visibility: visible !important;
        }

        .button {
            position: relative;
            padding: 1rem 2.5rem;
            font-size: 1.125rem;
            font-weight: 600;
            color: white !important;
            background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%) !important;
            border: none;
            border-radius: 0.75rem;
            cursor: pointer;
            overflow: hidden;
            transition: all 0.3s ease;
            box-shadow: 0 10px 30px rgba(99, 102, 241, 0.3), 0 0 20px rgba(139, 92, 246, 0.2);
            opacity: 1 !important;
            animation: fadeInUp 1s ease-out 0.6s forwards;
            visibility: visible !important;
        }

        .button::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: left 0.5s;
        }

        .button:hover::before { left: 100%; }
        .button:hover { transform: translateY(-2px) scale(1.05); box-shadow: 0 15px 40px rgba(99, 102, 241, 0.4), 0 0 30px rgba(139, 92, 246, 0.3); }
        .button:active { transform: translateY(0) scale(1.02); }

        .results-container,
        .progress-container {
            max-width: 960px;
            width: 100%;
            margin: 2.5rem auto 0;
            padding: 2rem;
            background: rgba(15, 23, 42, 0.65);
            backdrop-filter: blur(12px);
            border-radius: 1rem;
            border: 1px solid rgba(199, 210, 254, 0.12);
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.35);
            animation: fadeInUp 0.6s ease-out;
        }

        .counter {
            font-size: 1.25rem;
            color: #a5b4fc;
            margin-bottom: 1.25rem;
            font-weight: 600;
        }

        .progress-text {
            color: #a5b4fc;
            font-size: 1rem;
            text-align: center;
            margin-bottom: 0.75rem;
        }

        .progress-detail {
            margin-bottom: 0.85rem;
            font-size: 0.82rem;
            text-align: center;
            color: #cbd5f5;
            letter-spacing: 0.01em;
        }

        .storage-controls {
            margin-top: 0.85rem;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.5rem;
        }

        .storage-controls .button[disabled] {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .storage-status {
            min-height: 1.2rem;
            font-size: 0.85rem;
            color: #cbd5f5;
            text-align: center;
        }

        .demo-loading {
            position: fixed;
            inset: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: rgba(15, 23, 42, 0.82);
            backdrop-filter: blur(6px);
            z-index: 120;
        }

        .demo-spinner {
            width: 64px;
            height: 64px;
            border: 4px solid rgba(99, 102, 241, 0.25);
            border-top-color: rgba(129, 140, 248, 0.85);
            border-radius: 9999px;
            animation: demo-spin 1s linear infinite;
            box-shadow: 0 0 30px rgba(129, 140, 248, 0.3);
        }

        .demo-loading-message {
            margin-top: 1rem;
            font-size: 1rem;
            color: #e0e7ff;
            letter-spacing: 0.01em;
            text-align: center;
        }

        @keyframes demo-spin {
            to { transform: rotate(360deg); }
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: rgba(30, 41, 59, 0.5);
            border-radius: 4px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, #6366f1 0%, #8b5cf6 100%);
            transition: width 0.3s ease;
            border-radius: 4px;
            box-shadow: 0 0 10px rgba(99, 102, 241, 0.5);
        }

        .file-list {
            max-height: 420px;
            overflow-y: auto;
            padding-right: 0.5rem;
        }

        .file-list::-webkit-scrollbar { width: 8px; }
        .file-list::-webkit-scrollbar-track { background: rgba(15, 23, 42, 0.5); border-radius: 4px; }
        .file-list::-webkit-scrollbar-thumb { background: rgba(199, 210, 254, 0.35); border-radius: 4px; }
        .file-list::-webkit-scrollbar-thumb:hover { background: rgba(199, 210, 254, 0.55); }

        .file-item {
            padding: 0.75rem 1rem;
            margin-bottom: 0.5rem;
            background: rgba(30, 41, 59, 0.55);
            border-radius: 0.5rem;
            border-left: 3px solid #6366f1;
            color: #e0e7ff;
            font-family: 'Monaco', 'Menlo', 'Courier New', monospace;
            font-size: 0.9rem;
            word-break: break-all;
            transition: all 0.2s ease;
        }

        .file-item:hover { background: rgba(30, 41, 59, 0.8); border-left-color: #8b5cf6; transform: translateX(4px); }

        .hidden { display: none !important; }
        
        /* EMERGENCY: Ensure hero container is always visible unless explicitly hidden */
        .hero-container:not(.hidden) {
            display: flex !important;
            visibility: visible !important;
            opacity: 1 !important;
        }

        .viz-container {
            position: fixed !important;
            inset: 0 !important;
            display: grid !important;
            grid-template-columns: 1fr 360px !important;
            background: rgba(10, 14, 39, 1) !important;
            z-index: 100 !important;
            visibility: visible !important;
            opacity: 1 !important;
            overflow: hidden !important;
            /* Ensure both columns fit on screen */
            min-width: 0;
            max-width: 100vw;
        }

        .viz-graph {
            position: relative;
            width: 100%;
            height: 100%;
            min-height: 100vh;
            max-height: 100vh;
            background: rgba(10, 14, 39, 1);
            overflow: hidden;
            /* Ensure graph doesn't push sidebar off screen */
            min-width: 0;
        }
        
        .viz-graph canvas {
            display: block !important;
            width: 100% !important;
            height: 100% !important;
            pointer-events: auto !important;
            cursor: grab !important;
        }
        
        .viz-graph canvas:active {
            cursor: grabbing !important;
        }

        .viz-sidebar {
            display: flex !important;
            flex-direction: column !important;
            background: rgba(15, 23, 42, 0.95) !important;
            border-left: 1px solid rgba(199, 210, 254, 0.12) !important;
            overflow-y: auto !important;
            overflow-x: hidden !important;
            visibility: visible !important;
            opacity: 1 !important;
            width: 360px !important;
            min-width: 360px !important;
            max-width: 360px !important;
            z-index: 150 !important;
            position: relative !important;
            /* Ensure sidebar is always visible and can scroll */
            height: 100vh !important;
            box-sizing: border-box !important;
        }

        .viz-controls,
        .viz-inspector {
            padding: 1.5rem !important;
            overflow-y: auto !important;
            display: block !important;
            visibility: visible !important;
            opacity: 1 !important;
            z-index: 151 !important;
            position: relative !important;
        }

        .viz-controls {
            border-bottom: 1px solid rgba(199, 210, 254, 0.1);
        }

        .inspector-panel {
            display: none;
        }

        .inspector-panel.visible {
            display: block;
        }

        .inspector-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
            padding-bottom: 0.75rem;
            border-bottom: 1px solid rgba(199, 210, 254, 0.1);
        }

        .inspector-title {
            font-size: 1.125rem;
            font-weight: 600;
            color: #e0e7ff;
        }

        .inspector-close {
            background: none;
            border: none;
            color: #a5b4fc;
            font-size: 1.5rem;
            cursor: pointer;
            padding: 0.25rem 0.5rem;
        }

        .inspector-content {
            color: #e0e7ff;
        }

        .inspector-info {
            margin-bottom: 1.5rem;
        }

        .inspector-edges {
            margin-bottom: 1.25rem;
            display: grid;
            gap: 1rem;
        }

        .inspector-edges-section {
            background: rgba(30, 41, 59, 0.4);
            border: 1px solid rgba(148, 163, 184, 0.2);
            border-radius: 0.5rem;
            padding: 0.75rem;
        }

        .inspector-edges-title {
            font-size: 0.85rem;
            font-weight: 600;
            color: #c7d2fe;
            margin-bottom: 0.5rem;
        }

        .inspector-edge-list {
            display: flex;
            flex-direction: column;
            gap: 0.4rem;
        }

        .inspector-edge-btn {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            background: rgba(79, 70, 229, 0.2);
            border: 1px solid rgba(99, 102, 241, 0.35);
            border-radius: 0.5rem;
            padding: 0.45rem 0.6rem;
            color: #e0e7ff;
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .inspector-edge-btn:hover {
            background: rgba(99, 102, 241, 0.3);
            border-color: rgba(129, 140, 248, 0.6);
        }

        .inspector-edge-label {
            font-weight: 600;
            margin-bottom: 0.1rem;
        }

        .inspector-edge-meta {
            font-size: 0.7rem;
            color: #cbd5f5;
            margin-bottom: 0.1rem;
        }

        .inspector-edge-path {
            font-size: 0.68rem;
            color: #94a3b8;
            word-break: break-all;
        }

        .inspector-edge-empty,
        .inspector-edge-more {
            font-size: 0.75rem;
            color: #a5b4fc;
        }

        .info-row {
            margin-bottom: 0.75rem;
            font-size: 0.9rem;
            line-height: 1.6;
        }

        .info-row strong { color: #a5b4fc; margin-right: 0.4rem; }

        .info-row code {
            background: rgba(30, 41, 59, 0.6);
            padding: 0.15rem 0.4rem;
            border-radius: 0.25rem;
            font-size: 0.85em;
            color: #c7d2fe;
        }

        .inspector-code-container {
            margin-top: 1rem;
        }

        .inspector-code {
            max-height: 320px;
            overflow-y: auto;
            background: rgba(9, 13, 33, 0.85);
            border: 1px solid rgba(99, 102, 241, 0.25);
            border-radius: 0.5rem;
            padding: 1rem;
            color: #e0e7ff;
            font-size: 0.85rem;
        }

        .controls-section {
            margin-bottom: 1.5rem;
        }

        .controls-title {
            font-size: 1rem;
            font-weight: 600;
            color: #a5b4fc;
            margin-bottom: 0.75rem;
        }

        .control-toggle {
            display: flex;
            align-items: center;
            margin-bottom: 0.5rem;
            color: #e0e7ff;
            font-size: 0.9rem;
        }

        .control-toggle input { margin-right: 0.5rem; cursor: pointer; }

        .control-button {
            width: 100%;
            padding: 0.5rem 1rem;
            margin-bottom: 0.6rem;
            background: rgba(99, 102, 241, 0.25);
            border: 1px solid rgba(99, 102, 241, 0.3);
            border-radius: 0.5rem;
            color: #e0e7ff;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .control-button:hover { background: rgba(99, 102, 241, 0.35); border-color: rgba(99, 102, 241, 0.5); }

        .control-segmented {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 0.4rem;
            margin-bottom: 0.6rem;
        }

        .control-segmented-btn {
            padding: 0.45rem 0.6rem;
            border-radius: 0.5rem;
            border: 1px solid rgba(99, 102, 241, 0.35);
            background: rgba(99, 102, 241, 0.18);
            color: #e0e7ff;
            font-size: 0.85rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .control-segmented-btn:hover,
        .control-segmented-btn:focus {
            outline: none;
            background: rgba(99, 102, 241, 0.3);
            border-color: rgba(129, 140, 248, 0.6);
        }

        .control-segmented-btn.active {
            background: rgba(129, 140, 248, 0.5);
            border-color: rgba(165, 180, 252, 0.85);
            color: #f8fafc;
            font-weight: 600;
        }

        .control-filter {
            margin-bottom: 0.85rem;
        }

        .control-filter label {
            display: block;
            color: #a5b4fc;
            font-size: 0.85rem;
            margin-bottom: 0.35rem;
        }

        .control-filter input,
        .control-filter select {
            width: 100%;
            padding: 0.5rem;
            background: rgba(30, 41, 59, 0.55);
            border: 1px solid rgba(199, 210, 254, 0.18);
            border-radius: 0.4rem;
            color: #e0e7ff;
            font-size: 0.9rem;
        }

        .hover-info-primary {
            margin-bottom: 0.75rem;
        }

        .hover-info-name {
            font-weight: 600;
            color: #e0e7ff;
            font-size: 0.95rem;
            margin-bottom: 0.25rem;
        }

        .hover-info-path {
            font-size: 0.75rem;
            color: #94a3b8;
            word-break: break-all;
        }

        .hover-info-metrics {
            display: flex;
            flex-wrap: wrap;
            gap: 0.4rem;
            margin-bottom: 0.65rem;
        }

        .hover-info-badge {
            background: rgba(148, 163, 184, 0.2);
            color: #e2e8f0;
            padding: 0.25rem 0.5rem;
            border-radius: 9999px;
            font-size: 0.72rem;
            letter-spacing: 0.01em;
        }

        .hover-info-neighbors {
            display: flex;
            flex-wrap: wrap;
            gap: 0.35rem;
        }

        .hover-neighbor-btn {
            background: rgba(79, 70, 229, 0.2);
            border: 1px solid rgba(99, 102, 241, 0.4);
            color: #c7d2fe;
            border-radius: 9999px;
            padding: 0.25rem 0.65rem;
            font-size: 0.72rem;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .hover-neighbor-btn:hover {
            background: rgba(99, 102, 241, 0.35);
            border-color: rgba(99, 102, 241, 0.6);
        }

        .hover-neighbor-empty,
        .hover-neighbor-more {
            font-size: 0.75rem;
            color: #a5b4fc;
        }

        .viz-close-button {
            position: fixed !important;
            top: 1.5rem !important;
            right: 1.5rem !important;
            z-index: 200 !important;
            padding: 0.75rem 1.5rem !important;
            background: rgba(15, 23, 42, 0.95) !important;
            color: #e0e7ff !important;
            border: 1px solid rgba(199, 210, 254, 0.5) !important;
            border-radius: 0.5rem !important;
            cursor: pointer !important;
            transition: all 0.2s !important;
            display: block !important;
            visibility: visible !important;
            opacity: 1 !important;
            pointer-events: auto !important;
        }

        .viz-close-button:hover { background: rgba(15, 23, 42, 1) !important; border-color: rgba(199, 210, 254, 0.6) !important; }

        @media (max-width: 1024px) {
            .viz-container {
                grid-template-columns: 1fr;
            }

            .viz-sidebar {
                position: absolute !important;
                right: 0 !important;
                top: 0 !important;
                bottom: 0 !important;
                width: min(360px, 90vw) !important;
                max-width: min(360px, 90vw) !important;
                min-width: min(360px, 90vw) !important;
                height: 100vh !important;
                box-shadow: -12px 0 40px rgba(0, 0, 0, 0.5);
                z-index: 160 !important;
            }
        }
        
        /* For very small screens, ensure sidebar can be accessed */
        @media (max-width: 1400px) {
            .viz-container {
                /* On smaller screens, ensure sidebar doesn't get cut off */
                grid-template-columns: minmax(0, 1fr) 360px !important;
            }
        }
    </style>
</head>
<body>
    <div class="stars" id="stars"></div>
    <div class="gravity-particles">
        <div class="gravity-particle"></div>
        <div class="gravity-particle"></div>
        <div class="gravity-particle"></div>
    </div>
    
    <div class="hero-container">
        <div class="text-center space-y-6">
            <h1 class="title">HELIOS</h1>
            <p class="tagline">See the gravity of your code</p>
            <div style="display: flex; gap: 1rem; justify-content: center; flex-wrap: wrap;">
                <button class="button" id="selectBtn">Select Repository</button>
                <button class="button hidden" id="resumeBtn" style="background: rgba(129, 140, 248, 0.15); border: 1px solid rgba(129, 140, 248, 0.5);">
                    Resume Last Session
                </button>
                <button class="button" id="loadDemoBtn" type="button" style="background: rgba(34, 197, 94, 0.18); border: 1px solid rgba(34, 197, 94, 0.45); color: #bbf7d0;">
                    Load Demo
            </button>
            </div>
            <div class="storage-controls">
                <button class="button" id="clearStorageBtn" type="button" style="background: rgba(248, 113, 113, 0.15); border: 1px solid rgba(248, 113, 113, 0.35); color: #fecaca;">
                    Clear Stored Data
                </button>
                <button class="button" id="exportDbBtn" type="button" style="background: rgba(59, 130, 246, 0.15); border: 1px solid rgba(59, 130, 246, 0.35); color: #bfdbfe;" title="Export database for benchmarking">
                    Export Database
                </button>
                <div class="storage-status" id="storageStatus" role="status" aria-live="polite"></div>
            </div>
        </div>

        <div class="progress-container hidden" id="progressContainer">
            <div class="progress-text" id="progressText">Scanning files...</div>
            <div class="progress-detail hidden" id="progressDetail"></div>
            <div class="progress-bar">
                <div class="progress-fill" id="progressFill"></div>
            </div>
        </div>

        <div class="results-container hidden" id="resultsContainer">
            <div class="counter" id="counter">Found 0 JavaScript files</div>
            <div class="counter" id="functionsCounter" style="font-size: 1rem; opacity: 0.85;">0 functions extracted</div>
            <div class="file-list" id="fileList"></div>
            <button class="button hidden" id="visualizeBtn" style="margin-top: 2rem; position: sticky; bottom: 1rem; opacity: 1 !important; visibility: visible !important;">Visualize Graph</button>
        </div>
    </div>

    <div class="demo-loading hidden" id="demoLoading" role="status" aria-live="polite" aria-hidden="true">
        <div class="demo-spinner"></div>
        <div class="demo-loading-message" id="demoLoadingLabel">Loading demo dataset...</div>
    </div>

    <div class="viz-container hidden" id="vizContainer">
        <div class="viz-graph" id="vizGraph"></div>
        <div class="viz-sidebar">
            <div class="viz-controls" id="vizControls"></div>
            <div class="viz-inspector" id="vizInspector"></div>
        </div>
        <button class="viz-close-button" id="vizCloseBtn">Close Visualization</button>
    </div>

    <script type="module">
        // Suppress harmless browser extension messaging errors
        window.addEventListener('error', (event) => {
            if (event.message && event.message.includes('message channel closed before a response was received')) {
                // This is a harmless browser extension messaging error - suppress it
                event.preventDefault();
                console.debug('[HELIOS] Suppressed browser extension messaging error (harmless)');
                return false;
            }
        });

        window.addEventListener('unhandledrejection', (event) => {
            if (event.reason && typeof event.reason === 'object' && event.reason.message) {
                if (event.reason.message.includes('message channel closed before a response was received')) {
                    // This is a harmless browser extension messaging error - suppress it
                    event.preventDefault();
                    console.debug('[HELIOS] Suppressed browser extension messaging promise rejection (harmless)');
                    return false;
                }
            }
        });
        
        // Suppress console warnings about multiple d3.js instances (harmless - 3d-force-graph bundles d3-force)
        const originalWarn = console.warn;
        console.warn = function(...args) {
            const message = args.join(' ');
            if (typeof message === 'string' && 
                (message.includes('Multiple instances of d3') || 
                 message.includes('Multiple instances of D3'))) {
                // Suppress the warning - it's harmless (3d-force-graph bundles d3-force)
                console.debug('[HELIOS] Suppressed multiple d3.js instance warning (harmless)');
                return;
            }
            originalWarn.apply(console, args);
        };

        import { parserManager } from './src/parser/parser.js';
        import { extractJavaScript } from './src/extractors/javascript.js';
        import { SymbolTableManager } from './src/extractors/symbol-table.js';
        import { extractPython } from './src/extractors/python.js';
        import { buildCallGraph } from './src/extractors/call-graph.js';
        import { GraphVisualization } from './src/viz/graph-viz.js';
        import { InspectorPanel } from './src/viz/inspector.js';
        import { VisualizationControls } from './src/viz/controls.js';
        import { EmbeddingManager } from './src/embeddings/embedding-manager.js';
        import { detectEmbeddingEnvironment } from './src/embeddings/backend.js';
        import { buildFunctionEmbeddings, computeSimilarityGraph } from './src/embeddings/similarity.js';
        import { StorageWorkerClient } from './src/storage/client.js';
        import {
            computeFunctionFingerprint,
            computeFunctionFingerprintMap,
            loadEmbeddingsForFunctions,
            loadFunctionFingerprintMap,
            persistEmbeddingRun,
            tryLoadEmbeddingRun
        } from './src/embeddings/persistence.js';
        import { StorageWorkerClient } from './src/storage/client.js';
        import {
            saveLayoutSnapshot,
            loadLayoutSnapshot,
            deleteLayoutSnapshot,
            listLayoutSnapshots
        } from './src/storage/layout-persistence.js';
        import {
            saveAnalysisSnapshot,
            loadAnalysisSnapshot
        } from './src/storage/resume-flow.js';
        import {
            mergeGraphPayload,
            collectGraphPayload,
            GraphWorkerClient
        } from './src/graph/index.js';
        import { getDemoDataset } from './src/demo/demo-data.js';

        const starsContainer = document.getElementById('stars');
        const starCount = 120;
        for (let i = 0; i < starCount; i++) {
            const star = document.createElement('div');
            star.className = 'star';
            star.style.left = Math.random() * 100 + '%';
            star.style.top = Math.random() * 100 + '%';
            star.style.animationDelay = Math.random() * 3 + 's';
            starsContainer.appendChild(star);
        }

        const selectBtn = document.getElementById('selectBtn');
        const resumeBtn = document.getElementById('resumeBtn');
        const loadDemoBtn = document.getElementById('loadDemoBtn');
        const progressContainer = document.getElementById('progressContainer');
        const progressText = document.getElementById('progressText');
        const progressDetail = document.getElementById('progressDetail');
        const progressFill = document.getElementById('progressFill');
        const demoLoading = document.getElementById('demoLoading');
        const demoLoadingLabel = document.getElementById('demoLoadingLabel');
        const resultsContainer = document.getElementById('resultsContainer');
        const counter = document.getElementById('counter');
        const functionsCounter = document.getElementById('functionsCounter');
        const fileList = document.getElementById('fileList');
        const visualizeBtn = document.getElementById('visualizeBtn');
        const vizContainer = document.getElementById('vizContainer');
        const vizGraph = document.getElementById('vizGraph');
        const vizControls = document.getElementById('vizControls');
        const vizInspector = document.getElementById('vizInspector');
        const vizCloseBtn = document.getElementById('vizCloseBtn');
        
        // EMERGENCY: Force hero container visible on startup
        const heroContainer = document.querySelector('.hero-container');
        if (heroContainer) {
            heroContainer.classList.remove('hidden');
            heroContainer.style.setProperty('display', 'flex', 'important');
            heroContainer.style.setProperty('visibility', 'visible', 'important');
            heroContainer.style.setProperty('opacity', '1', 'important');
            heroContainer.style.setProperty('z-index', '5', 'important');
            console.log('[STARTUP] Hero container forced visible');
        } else {
            console.error('[STARTUP] CRITICAL: Hero container not found!');
        }
        
        // EMERGENCY: Force viz container hidden on startup
        if (vizContainer) {
            vizContainer.classList.add('hidden');
            vizContainer.style.setProperty('display', 'none', 'important');
            vizContainer.style.setProperty('visibility', 'hidden', 'important');
            vizContainer.style.setProperty('opacity', '0', 'important');
            console.log('[STARTUP] Viz container forced hidden');
        }
        
        // EMERGENCY: Verify we can see something
        setTimeout(() => {
            const hero = document.querySelector('.hero-container');
            const viz = document.getElementById('vizContainer');
            console.log('[STARTUP] Visibility check:', {
                heroVisible: hero && window.getComputedStyle(hero).display !== 'none',
                heroDisplay: hero ? window.getComputedStyle(hero).display : 'MISSING',
                vizHidden: viz && (viz.classList.contains('hidden') || window.getComputedStyle(viz).display === 'none'),
                bodyChildren: document.body.children.length
            });
            
            if (!hero || window.getComputedStyle(hero).display === 'none') {
                console.error('[STARTUP] CRITICAL: Hero container not visible! Forcing again...');
                if (hero) {
                    hero.style.setProperty('display', 'flex', 'important');
                    hero.style.setProperty('visibility', 'visible', 'important');
                }
            }
        }, 100);
        const clearStorageBtn = document.getElementById('clearStorageBtn');
        const exportDbBtn = document.getElementById('exportDbBtn');
        const storageStatusEl = document.getElementById('storageStatus');
        const STORAGE_FALLBACK_MESSAGE =
            'Storage ready (in-memory fallback). Enable COOP/COEP headers to unlock OPFS persistence.';
        if (clearStorageBtn) {
            clearStorageBtn.disabled = true;
        }
        if (exportDbBtn) {
            exportDbBtn.disabled = true;
        }

        function setProgressDetail(detailText) {
            if (!progressDetail) return;
            if (detailText && detailText.length) {
                progressDetail.textContent = detailText;
                progressDetail.classList.remove('hidden');
            } else {
                progressDetail.textContent = '';
                progressDetail.classList.add('hidden');
            }
        }

        function clearProgressDetail() {
            setProgressDetail('');
        }

        const SUPPORTED_EXTENSIONS = ['.js', '.jsx', '.ts', '.tsx', '.py'];
        const JS_FILE_EXTENSIONS = ['.js', '.jsx', '.ts', '.tsx', '.mjs', '.cjs'];
        const JS_INDEX_FILENAMES = ['index.js', 'index.jsx', 'index.ts', 'index.tsx'];
        const PY_FILE_EXTENSIONS = ['.py'];
        const PY_PACKAGE_FILENAMES = ['__init__.py'];
        const languageDisplayNames = {
            javascript: 'JavaScript',
            typescript: 'TypeScript',
            python: 'Python'
        };

        let sourceFiles = [];
        let fileHandles = new Map();
        const sourceFileIndex = new Map();
        const moduleIndex = new Map();
        let totalFiles = 0;
        let scannedFiles = 0;
        let allFunctions = [];
        let allCalls = [];
        let callGraph = null;

        let graphViz = null;
        let inspector = null;
        let controls = null;
        let fullVizData = null;
        let isDemoMode = false;
        let functionMapById = new Map();
        let embeddingManager = null;
        let embeddingChunks = [];
        let embeddingStats = null;
        let embeddingVectors = [];
        let embeddingMetadata = {
            backend: null,
            modelId: null,
            dimension: null
        };
        let embeddingError = null;
        let embeddingFingerprint = null;
        let usedCachedEmbeddings = false;
        let embeddingReuseCounts = { reused: 0, embedded: 0 };
        let embeddingEnvironment = {
            detected: false,
            backend: null,
            webgpuAvailable: false,
            forced: false,
            error: null
        };
        let embeddingEnvironmentSummary = null;
        let functionEmbeddings = [];
        let similarityEdges = [];
        let similarityStats = null;
        const similarityConfig = {
            maxNeighbors: 8,
            candidateLimit: 20,
            bundleTopK: 3,
            similarityThreshold: 0.65,
            approximate: false,
            approximateThreshold: 700,
            approximateProjectionCount: 12,
            approximateBandSize: 28,
            approximateOversample: 2
        };

        const graphWorkerClient = new GraphWorkerClient();

        let graphPayload = {
            functions: [],
            callEdges: [],
            similarityEdges: [],
            extras: null
        };
        let graphAnalysis = null;
        let graphSummary = null;
        let graphSerialized = { nodes: [], edges: [] };
        let graphExtras = null;

        let storageClient = null;
        let storageReady = false;
        let storageClientInitPromise = null;
        let storagePersistent = null;
        let latestEmbeddingSummary = null;
        let latestFunctionFingerprintMap = null;
        let resumeSnapshot = null;

        function showDemoLoading(message = 'Loading demo dataset...') {
            if (!demoLoading) {
                return;
            }
            if (demoLoadingLabel) {
                demoLoadingLabel.textContent = message;
            }
            demoLoading.classList.remove('hidden');
            demoLoading.setAttribute('aria-hidden', 'false');
        }

        function hideDemoLoading() {
            if (!demoLoading) {
                return;
            }
            demoLoading.classList.add('hidden');
            demoLoading.setAttribute('aria-hidden', 'true');
        }

        function computeSimilarityStatsFromEdges(edges = []) {
            if (!Array.isArray(edges) || edges.length === 0) {
                return null;
            }
            let min = Infinity;
            let max = -Infinity;
            let total = 0;
            let count = 0;
            edges.forEach(edge => {
                const value = typeof edge.similarity === 'number'
                    ? edge.similarity
                    : typeof edge.weight === 'number'
                        ? edge.weight
                        : null;
                if (!Number.isFinite(value)) {
                    return;
                }
                min = Math.min(min, value);
                max = Math.max(max, value);
                total += value;
                count += 1;
            });
            if (count === 0) {
                return null;
            }
            return {
                count,
                min,
                max,
                mean: total / count
            };
        }

        function resetAnalysisState({ showProgress = false, progressLabel = 'Preparing analysis...', resetVisualization = false } = {}) {
            sourceFiles = [];
            fileHandles = new Map();
            sourceFileIndex.clear();
            moduleIndex.clear();
            totalFiles = 0;
            scannedFiles = 0;
            allFunctions = [];
            allCalls = [];
            callGraph = null;
            fullVizData = null;
            functionMapById = new Map();
            embeddingChunks = [];
            embeddingStats = null;
            embeddingVectors = [];
            embeddingMetadata = {
                backend: embeddingEnvironment.backend || null,
                modelId: null,
                dimension: null
            };
            embeddingError = null;
            
            // Reset visualization state if requested (when selecting new repo or loading demo)
            if (resetVisualization && graphViz) {
                try {
                    graphViz.dispose?.();
                } catch (err) {
                    console.warn('[resetAnalysisState] Error disposing graphViz:', err);
                }
                graphViz = null;
                controls = null;
                inspector = null;
            }
            embeddingFingerprint = null;
            usedCachedEmbeddings = false;
            embeddingReuseCounts = { reused: 0, embedded: 0 };
            functionEmbeddings = [];
            similarityEdges = [];
            similarityStats = null;
            graphPayload = { functions: [], callEdges: [], similarityEdges: [], extras: null };
            graphAnalysis = null;
            graphSummary = null;
            graphSerialized = { nodes: [], edges: [] };
            graphExtras = null;
            latestEmbeddingSummary = null;
            latestFunctionFingerprintMap = null;
            resumeSnapshot = null;
            resumeBtn?.classList.add('hidden');
            if (symbolTableManager && typeof symbolTableManager.clear === 'function') {
                symbolTableManager.clear();
            }
            updateEmbeddingSummary(embeddingEnvironmentSummary || null);
            window.heliosEmbeddingChunks = [];
            window.heliosEmbeddingStats = null;
            window.heliosEmbeddings = null;
            window.heliosEmbeddingReuse = null;
            window.heliosEmbeddingError = null;
            window.heliosFunctionEmbeddings = null;
            window.heliosSimilarity = null;
            fileList.innerHTML = '';
            counter.textContent = 'No source files loaded yet';
            functionsCounter.textContent = '0 functions extracted';
            visualizeBtn.classList.add('hidden');
            progressFill.style.width = '0%';
            progressText.textContent = progressLabel;
            if (storageStatusEl) {
                storageStatusEl.textContent = '';
            }
            if (showProgress) {
                progressContainer.classList.remove('hidden');
            } else {
                progressContainer.classList.add('hidden');
            }
            resultsContainer.classList.add('hidden');
        }

        const symbolTableManager = new SymbolTableManager();

        function setStorageStatus(message, tone = 'info') {
            if (!storageStatusEl) {
                return;
            }
            const palette = {
                success: '#bbf7d0',
                error: '#fecaca',
                warning: '#fde68a',
                info: '#cbd5f5'
            };
            storageStatusEl.textContent = message || '';
            storageStatusEl.style.color = palette[tone] || palette.info;
        }

        setStorageStatus('Storage initializing…', 'info');
        function updateEmbeddingSummary(summary) {
            latestEmbeddingSummary = summary;
            if (controls && typeof controls.setEmbeddingSummary === 'function') {
                controls.setEmbeddingSummary(summary);
            }
        }

        function buildEmbeddingDetectionSummary(env) {
            if (!env || !env.detected) {
                return null;
            }
            const backend = env.backend || null;
            return {
                chunkCount: 0,
                metadata: { backend },
                detection: {
                    detected: true,
                    backend,
                    webgpuAvailable: Boolean(env.webgpuAvailable),
                    forced: Boolean(env.forced),
                    error: env.error || null
                },
                cached: false
            };
        }

        async function bootstrapEmbeddingDetection() {
            if (!embeddingManager) {
                embeddingEnvironment = {
                    detected: true,
                    backend: null,
                    webgpuAvailable: false,
                    forced: false,
                    error: 'Embeddings unavailable in this environment'
                };
            } else {
                try {
                    const info = await detectEmbeddingEnvironment();
                    embeddingEnvironment = {
                        detected: true,
                        backend: info?.backend || null,
                        webgpuAvailable: Boolean(info?.webgpuAvailable),
                        forced: Boolean(info?.forcedBackend),
                        error: null
                    };
                } catch (err) {
                    const message = err && err.message ? err.message : (err ? String(err) : 'Unknown detection error');
                    embeddingEnvironment = {
                        detected: true,
                        backend: null,
                        webgpuAvailable: false,
                        forced: false,
                        error: message
                    };
                }
            }

            if (!embeddingMetadata.backend && embeddingEnvironment.backend) {
                embeddingMetadata.backend = embeddingEnvironment.backend;
            }

            embeddingEnvironmentSummary = buildEmbeddingDetectionSummary(embeddingEnvironment);
            window.heliosEmbeddingEnvironment = embeddingEnvironment;
            if (embeddingEnvironmentSummary) {
                const hasEmbeddings =
                    latestEmbeddingSummary &&
                    Number.isFinite(latestEmbeddingSummary.chunkCount) &&
                    latestEmbeddingSummary.chunkCount > 0;
                const hasError = Boolean(latestEmbeddingSummary && latestEmbeddingSummary.error);
                if (!hasEmbeddings && !hasError) {
                    updateEmbeddingSummary(embeddingEnvironmentSummary);
                }
            }
        }

        try {
            embeddingManager = new EmbeddingManager();
            window.heliosEmbeddingManager = embeddingManager;
        } catch (err) {
            console.warn('Embeddings unavailable in this environment:', err);
            embeddingManager = null;
            window.heliosEmbeddingManager = null;
        }
        bootstrapEmbeddingDetection().catch(err => {
            console.warn('Embedding backend detection failed:', err);
        });

        if (!window.showDirectoryPicker) {
            selectBtn.textContent = 'File System Access API not supported';
            selectBtn.disabled = true;
            selectBtn.style.opacity = '0.5';
            selectBtn.style.cursor = 'not-allowed';
        }

        resumeBtn?.addEventListener('click', async () => {
            if (!resumeSnapshot) {
                return;
            }
            resumeBtn.classList.add('hidden');
            try {
                await hydrateFromSnapshot(resumeSnapshot);
            } catch (err) {
                console.error('Failed to resume previous session:', err);
                resumeBtn.classList.remove('hidden');
            }
        });

        clearStorageBtn?.addEventListener('click', async () => {
            if (clearStorageBtn.disabled) {
                return;
            }
            clearStorageBtn.disabled = true;
            setStorageStatus('Clearing stored data…', 'info');
            try {
                const available = storageClient || (await ensureStorageClient());
                if (!available || !storageClient) {
                    setStorageStatus('Storage unavailable; nothing to clear.', 'warning');
                    return;
                }

                const result = await storageClient.reset();
                storageReady = false;
                storageClientInitPromise = null;
                resumeSnapshot = null;
                resumeBtn?.classList.add('hidden');

                const message = result?.removed
                    ? 'Stored data cleared (OPFS file removed).'
                    : 'Stored data cleared.';

                const reinitialized = await ensureStorageClient();
                await initializeResumeOption();
                if (reinitialized) {
                    setStorageStatus(message, 'success');
                } else {
                    setStorageStatus(`${message} Enable COOP/COEP headers to unlock OPFS persistence.`, 'warning');
                }
            } catch (err) {
                console.error('Failed to clear stored data', err);
                setStorageStatus('Failed to clear stored data. See console for details.', 'error');
            } finally {
                clearStorageBtn.disabled = false;
            }
        });

        exportDbBtn?.addEventListener('click', async () => {
            if (exportDbBtn.disabled || !storageReady || !storageClient) {
                if (!storageReady || !storageClient) {
                    setStorageStatus('Storage not ready. Load a repository first.', 'warning');
                }
                return;
            }
            exportDbBtn.disabled = true;
            setStorageStatus('Exporting database…', 'info');
            try {
                const result = await storageClient.exportDatabase();
                if (!result || !result.bytes || result.bytes.length === 0) {
                    throw new Error('Export returned no data');
                }

                // Create download link
                // result.bytes is a Uint8Array from client.js
                const blob = new Blob([result.bytes], { type: 'application/x-sqlite3' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = result.dbName || 'helios.sqlite3';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);

                setStorageStatus(`Database exported (${(result.size / 1024).toFixed(1)} KB)`, 'success');
            } catch (err) {
                console.error('Failed to export database', err);
                setStorageStatus('Failed to export database. See console for details.', 'error');
            } finally {
                exportDbBtn.disabled = false;
            }
        });

        selectBtn.addEventListener('click', async () => {
            try {
                const directoryHandle = await window.showDirectoryPicker();
                
                resetAnalysisState({ showProgress: true, progressLabel: 'Initializing parser...', resetVisualization: true });
                embeddingMetadata.backend = embeddingEnvironment.backend || null;
                updateEmbeddingSummary(embeddingEnvironmentSummary || null);

                await parserManager.initialize();
                await ensureStorageClient();

                progressText.textContent = 'Counting files...';
                totalFiles = await countFiles(directoryHandle);
                progressText.textContent = 'Scanning files...';
                await scanDirectory(directoryHandle, '');
                
                progressText.textContent = 'Parsing source files...';
                await parseSourceFiles();
                
                progressText.textContent = 'Building call graph...';
                callGraph = buildCallGraph(allFunctions, allCalls, symbolTableManager);
                
                const stats = callGraph?.stats || { totalEdges: 0, staticEdges: 0, dynamicEdges: 0 };

                // Show results container and visualize button immediately after parsing/call graph
                // Embeddings can continue in background
                progressContainer.classList.add('hidden');
                isDemoMode = false; // Mark that we're parsing actual repo, not demo
                resultsContainer.classList.remove('hidden');
                visualizeBtn.classList.remove('hidden');
                visualizeBtn.style.display = 'block';
                visualizeBtn.style.visibility = 'visible';
                visualizeBtn.style.opacity = '1';
                
                counter.textContent = formatCounterMessage();
                functionsCounter.textContent = `${allFunctions.length} function${allFunctions.length !== 1 ? 's' : ''} extracted · ${stats.totalEdges} call edge${stats.totalEdges !== 1 ? 's' : ''} (${stats.staticEdges} static · ${stats.dynamicEdges} dynamic)`;
                displayResults();
                
                // Auto-open visualization after parsing repo (consistent with demo behavior)
                // This provides better UX - user doesn't need to click another button
                console.log('[Repo Selection] Auto-opening visualization after parsing...');
                try {
                    await initializeVisualization();
                } catch (err) {
                    console.error('[Repo Selection] Failed to auto-open visualization:', err);
                    console.error('[Repo Selection] Error details:', err?.stack || err);
                    // Don't hide results container on error - let user retry with visualize button
                    // The error is logged, but we keep the UI visible so user can click "Visualize Graph" to retry
                    alert('Visualization failed to open automatically. Please click "Visualize Graph" to retry.\n\nError: ' + (err?.message || err));
                }

                // Continue with embeddings in background (non-blocking)
                if (embeddingManager) {
                    try {
                        embeddingFingerprint = await computeFunctionFingerprint(allFunctions);
                    } catch (err) {
                        console.warn('Failed to compute embedding fingerprint:', err);
                        embeddingFingerprint = null;
                    }

                    try {
                        const prepared = embeddingManager.prepareFunctionChunks(allFunctions);
                        embeddingChunks = prepared.chunks;
                        embeddingStats = prepared.stats;
                        window.heliosEmbeddingChunks = embeddingChunks;
                        window.heliosEmbeddingStats = embeddingStats;

                        usedCachedEmbeddings = false;
                        let persistedEmbeddingData = null;

                        if (embeddingChunks.length > 0 && embeddingFingerprint) {
                            try {
                                progressText.textContent = 'Checking cached embeddings...';
                                persistedEmbeddingData = await tryLoadEmbeddingRun({
                                    functions: allFunctions,
                                    chunks: embeddingChunks,
                                    fingerprint: embeddingFingerprint
                                });
                            } catch (err) {
                                console.warn('Failed to load persisted embeddings:', err);
                            }
                        }

                        if (persistedEmbeddingData) {
                            usedCachedEmbeddings = true;
                            embeddingVectors = persistedEmbeddingData.embeddings || [];
                            embeddingMetadata = {
                                backend: persistedEmbeddingData.metadata?.backend || null,
                                modelId: persistedEmbeddingData.metadata?.modelId || null,
                                dimension: persistedEmbeddingData.metadata?.dimension || null,
                                quantized: persistedEmbeddingData.metadata?.quantized || false
                            };
                            latestFunctionFingerprintMap = persistedEmbeddingData.functionFingerprints || null;
                            embeddingReuseCounts = {
                                reused: embeddingChunks.length,
                                embedded: 0
                            };
                            similarityEdges = persistedEmbeddingData.similarityEdges || [];
                            window.heliosEmbeddings = {
                                chunks: embeddingChunks,
                                embeddings: embeddingVectors,
                                metadata: embeddingMetadata,
                                stats: embeddingStats,
                                cached: true,
                                reuse: embeddingReuseCounts
                            };
                            window.heliosEmbeddingError = null;
                            window.heliosEmbeddingReuse = embeddingReuseCounts;
                        } else if (embeddingChunks.length > 0) {
                            const functionFingerprintMap = computeFunctionFingerprintMap(allFunctions);
                            latestFunctionFingerprintMap = functionFingerprintMap;

                            let storedFunctionFingerprints = {};
                            try {
                                storedFunctionFingerprints = await loadFunctionFingerprintMap();
                            } catch (err) {
                                console.warn('Failed to load stored function fingerprints:', err);
                            }

                            const unchangedFunctionIds = [];
                            const changedFunctionIds = [];
                            allFunctions.forEach(fn => {
                                const currentFingerprint = functionFingerprintMap[fn.id];
                                const storedFingerprint = storedFunctionFingerprints?.[fn.id];
                                if (storedFingerprint && currentFingerprint === storedFingerprint) {
                                    unchangedFunctionIds.push(fn.id);
                                } else {
                                    changedFunctionIds.push(fn.id);
                                }
                            });

                            let reuseEmbeddings = [];
                            let reuseMetadata = null;
                            let reuseMissingFunctions = [];

                            if (unchangedFunctionIds.length > 0) {
                                progressText.textContent = `Reusing cached embeddings (${unchangedFunctionIds.length.toLocaleString()} function${unchangedFunctionIds.length !== 1 ? 's' : ''})...`;
                                try {
                                    const reuseResult = await loadEmbeddingsForFunctions({
                                        functions: allFunctions,
                                        chunks: embeddingChunks,
                                        targetFunctionIds: unchangedFunctionIds
                                    });
                                    reuseEmbeddings = reuseResult.embeddings || [];
                                    reuseMetadata = reuseResult.metadata || null;
                                    reuseMissingFunctions = reuseResult.missingFunctions || [];
                                } catch (err) {
                                    console.warn('Failed to reuse cached embeddings:', err);
                                }
                            }

                            const changedIdSet = new Set([
                                ...changedFunctionIds,
                                ...reuseMissingFunctions
                            ]);

                            const functionsToEmbed = allFunctions.filter(fn => changedIdSet.has(fn.id));
                            const chunksToEmbed = embeddingChunks.filter(chunk => changedIdSet.has(chunk.functionId));

                            let embeddingResult = {
                                chunks: chunksToEmbed,
                                embeddings: [],
                                backend: null,
                                modelId: null,
                                dimension: null,
                                stats: null
                            };

                            if (functionsToEmbed.length > 0) {
                                progressText.textContent = `Initializing embedding model (${chunksToEmbed.length.toLocaleString()} chunk${chunksToEmbed.length !== 1 ? 's' : ''})...`;
                                const initInfo = await embeddingManager.initialize();
                                embeddingMetadata = {
                                    backend: initInfo.backend || embeddingMetadata.backend,
                                    modelId: initInfo.modelId || embeddingMetadata.modelId,
                                    dimension: initInfo.dimension || embeddingMetadata.dimension
                                };

                                const totalTokens = chunksToEmbed.reduce(
                                    (sum, chunk) => sum + (chunk.tokenCount ?? 0),
                                    0
                                );
                                const preparedSubset = {
                                    chunks: chunksToEmbed,
                                    stats: {
                                        processedFunctions: functionsToEmbed.length,
                                        chunkCount: chunksToEmbed.length,
                                        totalTokens,
                                        averageTokens: chunksToEmbed.length ? totalTokens / chunksToEmbed.length : 0,
                                        averageChunksPerFunction: functionsToEmbed.length ? chunksToEmbed.length / functionsToEmbed.length : 0
                                    }
                                };

                                progressText.textContent = `Generating embeddings (${chunksToEmbed.length.toLocaleString()} chunk${chunksToEmbed.length !== 1 ? 's' : ''})...`;
                                embeddingResult = await embeddingManager.embedFunctions(functionsToEmbed, {
                                    preparedChunks: preparedSubset
                                });
                            } else if (reuseMetadata) {
                                embeddingMetadata = {
                                    backend: reuseMetadata.backend ?? embeddingMetadata.backend,
                                    modelId: reuseMetadata.modelId ?? embeddingMetadata.modelId,
                                    dimension: reuseMetadata.dimension ?? embeddingMetadata.dimension
                                };
                            }

                            embeddingVectors = [
                                ...(reuseEmbeddings || []),
                                ...(embeddingResult.embeddings || [])
                            ];

                            embeddingMetadata = {
                                backend: embeddingResult.backend || embeddingMetadata.backend || reuseMetadata?.backend || null,
                                modelId: embeddingResult.modelId || embeddingMetadata.modelId || reuseMetadata?.modelId || null,
                                dimension: embeddingResult.dimension || embeddingMetadata.dimension || reuseMetadata?.dimension || null
                            };

                            embeddingReuseCounts = {
                                reused: reuseEmbeddings.length,
                                embedded: embeddingResult.embeddings?.length || 0
                            };

                            window.heliosEmbeddings = {
                                chunks: embeddingChunks,
                                embeddings: embeddingVectors,
                                metadata: embeddingMetadata,
                                stats: embeddingStats,
                                reuse: embeddingReuseCounts,
                                partial: true
                            };
                            window.heliosEmbeddingError = null;
                            window.heliosEmbeddingReuse = embeddingReuseCounts;
                        } else {
                            embeddingMetadata = {
                                backend: null,
                                modelId: embeddingManager?.modelId || null,
                                dimension: null
                            };
                            window.heliosEmbeddings = {
                                chunks: [],
                                embeddings: [],
                                metadata: embeddingMetadata,
                                stats: embeddingStats,
                                reuse: embeddingReuseCounts
                            };
                            window.heliosEmbeddingError = null;
                            window.heliosEmbeddingReuse = embeddingReuseCounts;
                        }
                    } catch (err) {
                        embeddingError = err;
                        window.heliosEmbeddingError = err;
                        console.error('Embedding pipeline failed:', err);
                    }
                }

                if (embeddingVectors.length > 0 && embeddingMetadata.dimension) {
                    functionEmbeddings = buildFunctionEmbeddings({
                        functions: allFunctions,
                        embeddings: embeddingVectors,
                        dimension: embeddingMetadata.dimension
                    });
                    if (!usedCachedEmbeddings) {
                        const similarityOptions = {
                            ...similarityConfig,
                            modelId: embeddingMetadata.modelId || null
                        };
                        const similarityResult = computeSimilarityGraph(functionEmbeddings, similarityOptions);
                        similarityEdges = similarityResult.edges || [];
                        similarityStats = similarityResult.stats || null;
                        window.heliosSimilarity = similarityResult;
                    } else {
                        similarityStats = {
                            functionsWithEmbeddings: functionEmbeddings.length,
                            finalEdges: similarityEdges.length,
                            cached: true
                        };
                        window.heliosSimilarity = {
                            edges: similarityEdges,
                            stats: similarityStats
                        };
                    }
                    window.heliosFunctionEmbeddings = functionEmbeddings;
                } else {
                    functionEmbeddings = [];
                    similarityEdges = [];
                    similarityStats = null;
                    window.heliosFunctionEmbeddings = null;
                    window.heliosSimilarity = null;
                }

                // Update graph data as embeddings complete
                await updateGraphData({
                    parser: {
                        functions: allFunctions,
                        callEdges: Array.isArray(callGraph?.edges) ? callGraph.edges : [],
                        stats: callGraph?.stats || null,
                        symbolTables: exportSymbolTables(symbolTableManager)
                    },
                    embeddings: {
                        similarityEdges: Array.isArray(similarityEdges) ? similarityEdges : [],
                        metadata: embeddingMetadata || null,
                        stats: similarityStats || null,
                        functionEmbeddings: Array.isArray(functionEmbeddings) && functionEmbeddings.length > 0 ? functionEmbeddings : undefined
                    }
                });

                updateEmbeddingSummary({
                    chunkCount: embeddingChunks.length,
                    metadata: embeddingMetadata,
                    reuse: embeddingReuseCounts,
                    cached: usedCachedEmbeddings,
                    similarityEdges: Array.isArray(similarityEdges) ? similarityEdges.length : null,
                    functionsWithEmbeddings: Array.isArray(functionEmbeddings) ? functionEmbeddings.length : null,
                    error: embeddingError,
                    detection: embeddingEnvironment.detected
                        ? {
                            detected: true,
                            backend: embeddingEnvironment.backend,
                            webgpuAvailable: Boolean(embeddingEnvironment.webgpuAvailable),
                            forced: Boolean(embeddingEnvironment.forced),
                            error: embeddingEnvironment.error
                        }
                        : null
                });

                // Update counter with embedding info if available
                const resolutionDetails = [];
                if (typeof stats.resolvedEdges === 'number') {
                    resolutionDetails.push(`${stats.resolvedEdges} resolved`);
                }
                if (typeof stats.ambiguousEdges === 'number' && stats.ambiguousEdges > 0) {
                    resolutionDetails.push(`${stats.ambiguousEdges} ambiguous`);
                }
                if (typeof stats.unresolvedEdges === 'number' && stats.unresolvedEdges > 0) {
                    resolutionDetails.push(`${stats.unresolvedEdges} unresolved`);
                }
                const resolutionSummary = resolutionDetails.length ? ` · ${resolutionDetails.join(' / ')}` : '';

                let embeddingSummary = '';
                if (embeddingManager && embeddingError) {
                    embeddingSummary = ' · Embeddings failed';
                } else if (embeddingChunks.length > 0) {
                    const dim = embeddingMetadata.dimension ? `${embeddingMetadata.dimension}-dim` : 'unknown-dim';
                    const backendLabel = embeddingMetadata.backend ? embeddingMetadata.backend.toUpperCase() : 'WASM';
                    let reuseLabel = '';
                    if (usedCachedEmbeddings) {
                        reuseLabel = ', cached';
                    } else if (embeddingReuseCounts.reused > 0) {
                        const reusedLabel = `${embeddingReuseCounts.reused.toLocaleString()} reused`;
                        const embeddedLabel = embeddingReuseCounts.embedded > 0
                            ? ` / ${embeddingReuseCounts.embedded.toLocaleString()} new`
                            : '';
                        reuseLabel = `, ${reusedLabel}${embeddedLabel}`;
                    }
                    embeddingSummary = ` · ${embeddingChunks.length.toLocaleString()} embedding chunk${embeddingChunks.length !== 1 ? 's' : ''} (${dim}, ${backendLabel}${reuseLabel})`;
                }

                let similaritySummary = '';
                if (similarityEdges.length > 0) {
                    similaritySummary = ` · ${similarityEdges.length.toLocaleString()} similarity edge${similarityEdges.length !== 1 ? 's' : ''}`;
                }

                // Update functions counter with embedding info as it becomes available
                functionsCounter.textContent = `${allFunctions.length} function${allFunctions.length !== 1 ? 's' : ''} extracted · ${stats.totalEdges} call edge${stats.totalEdges !== 1 ? 's' : ''} (${stats.staticEdges} static · ${stats.dynamicEdges} dynamic)${resolutionSummary}${embeddingSummary}${similaritySummary}`;

                if (!usedCachedEmbeddings && embeddingVectors.length > 0) {
                    try {
                        progressText.textContent = 'Persisting embeddings...';
                        await persistEmbeddingRun({
                            functions: allFunctions,
                            chunks: embeddingChunks,
                            embeddings: embeddingVectors,
                            similarityEdges,
                            metadata: {
                                backend: embeddingMetadata.backend,
                                modelId: embeddingMetadata.modelId,
                                dimension: embeddingMetadata.dimension,
                                quantized: embeddingManager?.quantized ?? true
                            },
                            fingerprint: embeddingFingerprint || ''
                        }, {
                            functionFingerprints: latestFunctionFingerprintMap
                        });
                    } catch (err) {
                        console.warn('Failed to persist embedding results:', err);
                    }
                }

                displayResults();

                if (storageReady && storageClient && callGraph?.nodes?.length) {
                    try {
                        const snapshotLayoutKey = computeLayoutStorageKey(callGraph);
                        const savedSnapshot = await saveAnalysisSnapshot(storageClient, {
                            projectLabel: directoryHandle?.name || null,
                            sourceFiles,
                            callGraph,
                            similarityEdges,
                            embedding: {
                                metadata: embeddingMetadata,
                                reuse: embeddingReuseCounts,
                                stats: embeddingStats,
                                chunkCount: embeddingChunks.length,
                                cached: usedCachedEmbeddings,
                                error: embeddingError
                            },
                            embeddingFingerprint,
                            functionFingerprintMap: latestFunctionFingerprintMap,
                            layoutKey: snapshotLayoutKey
                        });
                        resumeSnapshot = savedSnapshot;
                        resumeBtn?.classList.remove('hidden');
                    } catch (err) {
                        console.warn('Failed to save analysis snapshot:', err);
                    }
                }

                // Ensure visualize button is shown if we have any graph data
                // Button was already shown when resultsContainer was displayed,
                // but hide it if we truly have no data
                if (allFunctions.length === 0 && (!callGraph || !callGraph.nodes || callGraph.nodes.length === 0)) {
                    visualizeBtn.classList.add('hidden');
                    visualizeBtn.style.display = 'none';
                } else {
                    visualizeBtn.classList.remove('hidden');
                    visualizeBtn.style.display = 'block';
                    visualizeBtn.style.visibility = 'visible';
                    visualizeBtn.style.opacity = '1';
                }

                window.heliosFunctions = allFunctions;
                window.heliosCalls = allCalls;
                window.heliosCallGraph = callGraph;
                window.heliosSymbolTables = symbolTableManager;

            } catch (error) {
                if (error?.name !== 'AbortError') {
                    console.error('Error selecting directory:', error);
                    progressText.textContent = 'Error: ' + (error?.message || 'Unknown error');
                    setTimeout(() => progressContainer.classList.add('hidden'), 3000);
                }
            }
        });

        loadDemoBtn?.addEventListener('click', async () => {
            if (loadDemoBtn.disabled) {
                return;
            }
            await loadDemoExperience();
        });

        visualizeBtn.addEventListener('click', async () => {
            if (!callGraph || !callGraph.nodes?.length) {
                alert('No call graph data available yet.');
                return;
            }
            await initializeVisualization();
        });

        function handleCloseVisualization() {
            console.log('[Visualization] Close button clicked');
            
            // Hide visualization container
            if (vizContainer) {
                vizContainer.classList.add('hidden');
                vizContainer.style.setProperty('display', 'none', 'important');
                vizContainer.style.setProperty('visibility', 'hidden', 'important');
                vizContainer.style.setProperty('opacity', '0', 'important');
                vizContainer.style.setProperty('z-index', '-1', 'important');
            }
            
            if (inspector) inspector.hide();
            
            // UX Improvement: After closing visualization, clear results and return to hero page
            // This provides a clean slate and makes it clear the user can select a new repo
            // Show hero container again when closing visualization
            const heroContainer = document.querySelector('.hero-container');
            if (heroContainer) {
                heroContainer.classList.remove('hidden');
                heroContainer.style.setProperty('display', 'flex', 'important');
                heroContainer.style.setProperty('visibility', 'visible', 'important');
                heroContainer.style.setProperty('opacity', '1', 'important');
                heroContainer.style.setProperty('z-index', '5', 'important');
            }
            
            // Hide results container and visualize button to return to clean state
            // User can then select a new repo or load demo from the hero page
            if (resultsContainer) {
                resultsContainer.classList.add('hidden');
                resultsContainer.style.setProperty('display', 'none', 'important');
            }
            
            if (visualizeBtn) {
                visualizeBtn.classList.add('hidden');
                visualizeBtn.style.display = 'none';
                visualizeBtn.blur(); // Remove focus to prevent auto-click
            }
            
            // Reset demo mode flag when closing
            isDemoMode = false;
        }

        if (vizCloseBtn) {
            console.log('[STARTUP] Setting up close button handler, button exists:', !!vizCloseBtn);
            vizCloseBtn.addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();
                handleCloseVisualization();
            });
            // Also try mousedown/touchstart as fallback
            vizCloseBtn.addEventListener('mousedown', (e) => {
                e.preventDefault();
                e.stopPropagation();
                handleCloseVisualization();
            });
        } else {
            console.error('[STARTUP] ERROR: vizCloseBtn not found!');
        }

        async function scanDirectory(directoryHandle, currentPath) {
                for await (const entry of directoryHandle.values()) {
                    if (entry.kind === 'file') {
                        scannedFiles++;
                        const fileName = entry.name;
                        const fullPath = currentPath ? `${currentPath}/${fileName}` : fileName;
                        
                    const extension = getExtension(fileName);
                    if (SUPPORTED_EXTENSIONS.includes(extension)) {
                        const language = parserManager.detectLanguage(fullPath);
                        if (language) {
                            const { moduleId, aliases } = createModuleMetadata(fullPath, language);
                            const fileMeta = { path: fullPath, language, moduleId, moduleAliases: aliases };
                            sourceFiles.push(fileMeta);
                            fileHandles.set(fullPath, entry);
                            registerSourceFile(fileMeta);
                        }
                    }

                    updateProgress('Scanning...', scannedFiles, totalFiles);
                    } else if (entry.kind === 'directory') {
                        const dirName = entry.name.toLowerCase();
                    if (['node_modules', '.git', 'dist', 'build', '.next', 'out', 'coverage'].includes(dirName)) {
                            continue;
                        }
                        const newPath = currentPath ? `${currentPath}/${entry.name}` : entry.name;
                        await scanDirectory(entry, newPath);
                    }
            }
        }

        async function countFiles(directoryHandle) {
            let count = 0;
                for await (const entry of directoryHandle.values()) {
                    if (entry.kind === 'file') {
                        count++;
                    } else if (entry.kind === 'directory') {
                        const dirName = entry.name.toLowerCase();
                    if (['node_modules', '.git', 'dist', 'build', '.next', 'out', 'coverage'].includes(dirName)) {
                            continue;
                        }
                        count += await countFiles(entry);
                    }
            }
            return count;
        }

        async function loadDemoExperience() {
            loadDemoBtn.disabled = true;
            showDemoLoading('Loading demo dataset...');
            try {
                await ensureStorageClient();
                const demo = getDemoDataset();

                resetAnalysisState({ showProgress: false, progressLabel: 'Preparing demo dataset...', resetVisualization: true });

                sourceFiles = Array.isArray(demo.sourceFiles)
                    ? demo.sourceFiles.map(file => ({ ...file }))
                    : [];
                sourceFiles.forEach(registerSourceFile);

                allFunctions = Array.isArray(demo.functions)
                    ? demo.functions.map(fn => ({ ...fn }))
                    : [];
                allCalls = Array.isArray(demo.calls)
                    ? demo.calls.map(call => ({ ...call }))
                    : [];
                functionMapById = new Map(allFunctions.map(fn => [fn.id, fn]));

                const callGraphNodes = Array.isArray(demo.callGraph?.nodes)
                    ? demo.callGraph.nodes.map(node => ({ ...node }))
                    : allFunctions.map(fn => ({
                        id: fn.id,
                        name: fn.name,
                        fqName: fn.fqName || fn.name || fn.id,
                        filePath: fn.filePath,
                        lang: fn.lang,
                        moduleId: fn.moduleId || null,
                        loc: fn.loc || fn.metrics?.size || 0
                    }));

                const callGraphEdges = Array.isArray(demo.callGraph?.edges)
                    ? demo.callGraph.edges.map(edge => ({
                        ...edge,
                        metadata: edge.metadata ? { ...edge.metadata } : null
                    }))
                    : [];

                const callGraphStats = demo.callGraph?.stats || {
                    totalNodes: callGraphNodes.length,
                    totalEdges: callGraphEdges.length,
                    staticEdges: callGraphEdges.length,
                    dynamicEdges: 0,
                    resolvedEdges: callGraphEdges.length,
                    ambiguousEdges: 0,
                    unresolvedEdges: 0
                };

                callGraph = {
                    nodes: callGraphNodes,
                    edges: callGraphEdges,
                    stats: callGraphStats
                };

                similarityEdges = Array.isArray(demo.similarityEdges)
                    ? demo.similarityEdges.map(edge => ({ ...edge }))
                    : [];
                similarityStats = computeSimilarityStatsFromEdges(similarityEdges);

                const demoEmbedding = demo.embedding || {};
                embeddingMetadata = {
                    backend: demoEmbedding.metadata?.backend || 'demo',
                    modelId: demoEmbedding.metadata?.modelId || 'helios-demo',
                    dimension: demoEmbedding.metadata?.dimension || null
                };
                embeddingStats = demoEmbedding.stats || null;
                embeddingChunks = Array.isArray(demoEmbedding.chunks) ? demoEmbedding.chunks.slice() : [];
                embeddingVectors = [];
                functionEmbeddings = Array.isArray(demoEmbedding.functionEmbeddings)
                    ? demoEmbedding.functionEmbeddings.slice()
                    : [];
                embeddingReuseCounts = {
                    reused: demoEmbedding.reuse?.reused ?? demoEmbedding.chunkCount ?? 0,
                    embedded: demoEmbedding.reuse?.embedded ?? 0
                };
                usedCachedEmbeddings = true;
                embeddingError = demoEmbedding.error || null;
                latestFunctionFingerprintMap = demoEmbedding.functionFingerprintMap || null;

                updateEmbeddingSummary({
                    chunkCount: demoEmbedding.chunkCount ?? functionEmbeddings.length,
                    metadata: embeddingMetadata,
                    reuse: embeddingReuseCounts,
                    cached: true,
                    similarityEdges: similarityEdges.length,
                    functionsWithEmbeddings: demoEmbedding.functionsWithEmbeddings ?? allFunctions.length,
                    error: embeddingError
                });

                await updateGraphData({
                    parser: {
                        functions: allFunctions,
                        callEdges: callGraphEdges,
                        stats: callGraphStats,
                        symbolTables: demo.symbolTables || null
                    },
                    embeddings: {
                        similarityEdges,
                        metadata: embeddingMetadata,
                        stats: demoEmbedding.stats || similarityStats || null,
                        functionEmbeddings
                    }
                });

                window.heliosFunctions = allFunctions;
                window.heliosCallGraph = callGraph;
                window.heliosSimilarity = similarityEdges;
                window.heliosEmbeddingStats = embeddingStats;
                window.heliosEmbeddingError = embeddingError;
                window.heliosParserStats = {
                    parsedFiles: sourceFiles.length,
                    functionsExtracted: allFunctions.length,
                    callsDetected: callGraphEdges.length,
                    largeRepo: allFunctions.length >= 1000
                };

                counter.textContent = formatCounterMessage();

                const resolutionParts = [];
                if (callGraphStats.resolvedEdges) resolutionParts.push(`${callGraphStats.resolvedEdges} resolved`);
                if (callGraphStats.ambiguousEdges) resolutionParts.push(`${callGraphStats.ambiguousEdges} ambiguous`);
                if (callGraphStats.unresolvedEdges) resolutionParts.push(`${callGraphStats.unresolvedEdges} unresolved`);
                const resolutionSummary = resolutionParts.length ? ` · ${resolutionParts.join(' / ')}` : '';

                const embeddingSummary = (() => {
                    const chunkCount = demoEmbedding.chunkCount ?? functionEmbeddings.length;
                    if (embeddingError) {
                        return ' · Embeddings failed';
                    }
                    if (chunkCount <= 0) {
                        return '';
                    }
                    const dimLabel = embeddingMetadata.dimension ? `${embeddingMetadata.dimension}-dim` : 'unknown-dim';
                    const backendLabel = embeddingMetadata.backend ? embeddingMetadata.backend.toUpperCase() : 'WASM';
                    let reuseLabel = '';
                    if (embeddingReuseCounts.reused > 0 || embeddingReuseCounts.embedded > 0) {
                        const reusedLabel = `${embeddingReuseCounts.reused.toLocaleString()} reused`;
                        const embeddedLabel = embeddingReuseCounts.embedded > 0
                            ? ` / ${embeddingReuseCounts.embedded.toLocaleString()} new`
                            : '';
                        reuseLabel = `, ${reusedLabel}${embeddedLabel}`;
                    } else {
                        reuseLabel = ', cached';
                    }
                    return ` · ${chunkCount.toLocaleString()} embedding chunk${chunkCount !== 1 ? 's' : ''} (${dimLabel}, ${backendLabel}${reuseLabel})`;
                })();

                const similaritySummary = similarityEdges.length
                    ? ` · ${similarityEdges.length.toLocaleString()} similarity edge${similarityEdges.length !== 1 ? 's' : ''}`
                    : '';

                functionsCounter.textContent = `${allFunctions.length} function${allFunctions.length !== 1 ? 's' : ''} extracted · ${callGraphStats.totalEdges} call edge${callGraphStats.totalEdges !== 1 ? 's' : ''} (${callGraphStats.staticEdges} static · ${callGraphStats.dynamicEdges} dynamic)${resolutionSummary}${embeddingSummary}${similaritySummary}`;

                displayResults();
                visualizeBtn.classList.remove('hidden');
                visualizeBtn.style.display = 'block';
                visualizeBtn.style.visibility = 'visible';
                visualizeBtn.style.opacity = '1';
                resultsContainer.classList.remove('hidden');
                resultsContainer.style.display = 'block';
                resultsContainer.style.visibility = 'visible';

                if (demoLoadingLabel) {
                    demoLoadingLabel.textContent = 'Rendering visualization...';
                }

                console.log('[Demo] Auto-opening visualization...');
                await initializeVisualization();
                if (controls && similarityStats) {
                    controls.updateSimilarityControls(similarityStats, { minWeight: similarityStats.min ?? 0 });
                }

                setStorageStatus('Demo dataset loaded (in-memory sample).', 'info');
                console.log('[Demo] Visualization should now be visible');
            } catch (err) {
                console.error('[Demo] Failed to load demo dataset:', err);
                console.error('[Demo] Error details:', err?.stack || err);
                alert('Failed to load demo dataset: ' + (err?.message || err) + '\n\nCheck console for details.');
            } finally {
                hideDemoLoading();
                loadDemoBtn.disabled = false;
            }
        }

        function abbreviatePath(path, maxLength = 72) {
            if (!path) return '';
            if (path.length <= maxLength) return path;
            const suffixLength = Math.floor((maxLength - 1) / 2);
            const prefixLength = maxLength - suffixLength - 1;
            const prefix = path.slice(0, prefixLength);
            const suffix = path.slice(-suffixLength);
            return `${prefix}…${suffix}`;
        }

        function buildScanDetail({ fullPath, queuedCount }) {
            const segments = [];
            if (typeof queuedCount === 'number' && queuedCount > 0) {
                segments.push(`Eligible files: ${queuedCount.toLocaleString()}`);
            }
            if (fullPath) {
                segments.push(`Latest: ${abbreviatePath(fullPath)}`);
            }
            return segments.join(' • ');
        }

        function buildParsingDetail({ functionsCount, callCount, currentFile, languageId, largeRepo }) {
            const segments = [];
            const fnCount = Number.isFinite(functionsCount) ? functionsCount : 0;
            const callTotal = Number.isFinite(callCount) ? callCount : 0;
            segments.push(`Functions: ${fnCount.toLocaleString()}`);
            segments.push(`Calls: ${callTotal.toLocaleString()}`);
            if (languageId) {
                segments.push(`Lang: ${languageDisplayNames[languageId] || languageId}`);
            }
            if (currentFile) {
                segments.push(`Latest: ${abbreviatePath(currentFile)}`);
            }
            if (largeRepo) {
                segments.push('Large repo mode');
            }
            return segments.join(' • ');
        }

        function buildCallGraphDetail(stats, parseStats) {
            if (!stats) {
                return '';
            }
            const segments = [];
            const totalEdges = Number.isFinite(stats.totalEdges) ? stats.totalEdges : null;
            const resolvedEdges = Number.isFinite(stats.resolvedEdges) ? stats.resolvedEdges : null;
            const ambiguousEdges = Number.isFinite(stats.ambiguousEdges) ? stats.ambiguousEdges : null;
            const unresolvedEdges = Number.isFinite(stats.unresolvedEdges) ? stats.unresolvedEdges : null;
            if (totalEdges !== null) {
                segments.push(`Call edges: ${totalEdges.toLocaleString()}`);
            }
            if (resolvedEdges !== null) {
                segments.push(`Resolved: ${resolvedEdges.toLocaleString()}`);
            }
            if (ambiguousEdges !== null) {
                segments.push(`Ambiguous: ${ambiguousEdges.toLocaleString()}`);
            }
            if (unresolvedEdges !== null) {
                segments.push(`Unresolved: ${unresolvedEdges.toLocaleString()}`);
            }
            if (parseStats && Number.isFinite(parseStats.functionsExtracted)) {
                segments.push(`Functions: ${parseStats.functionsExtracted.toLocaleString()}`);
            }
            return segments.join(' • ');
        }

        function updateProgress(label, current, total, options = {}) {
            const { unit = 'files', detail, render } = options || {};
            if (!total || !Number.isFinite(total)) {
                progressFill.style.width = '0%';
                if (options && Object.prototype.hasOwnProperty.call(options, 'detail')) {
                    setProgressDetail(detail);
                }
                progressText.textContent = label;
                return;
            }

            const progress = Math.min((current / total) * 100, 100);
            progressFill.style.width = `${progress}%`;

            if (typeof render === 'function') {
                progressText.textContent = render({ label, current, total, unit });
            } else {
                progressText.textContent = `${label} ${current.toLocaleString()} of ${total.toLocaleString()} ${unit}`;
            }

            if (options && Object.prototype.hasOwnProperty.call(options, 'detail')) {
                setProgressDetail(detail);
            }
        }

        async function parseSourceFiles() {
            const total = sourceFiles.length;
            if (!total) {
                clearProgressDetail();
                return {
                    parsedFiles: 0,
                    functionsExtracted: 0,
                    callsDetected: 0,
                    largeRepo: false
                };
            }

            const languageCache = new Map();
            let parsedCount = 0;
            let extractedFunctionCount = 0;
            let extractedCallCount = 0;
            const largeRepoThreshold = 1000;
            let largeRepoNotified = false;

            for (const file of sourceFiles) {
                const detailPath = file.path;
                let currentLanguageId = null;
                try {
                    currentLanguageId = file.language || null;
                    if (!currentLanguageId) {
                        continue;
                    }

                    const extractor = getExtractorForLanguage(currentLanguageId);
                    if (!extractor) {
                        continue;
                    }

                    if (!languageCache.has(currentLanguageId)) {
                        const loadedLanguage = await parserManager.loadLanguage(currentLanguageId);
                        languageCache.set(currentLanguageId, loadedLanguage);
                    }
                    const language = languageCache.get(currentLanguageId);

                    const fileHandle = fileHandles.get(detailPath);
                    if (!fileHandle) {
                        continue;
                    }

                    const fileBlob = await fileHandle.getFile();
                    const source = await fileBlob.text();

                    const extracted = await extractor(source, detailPath, language, currentLanguageId);

                    const annotatedFunctions = annotateFunctions(extracted.functions, currentLanguageId, file.moduleId);
                    allFunctions.push(...annotatedFunctions);
                    const annotatedCalls = annotateCalls(extracted.calls, currentLanguageId);
                    allCalls.push(...annotatedCalls);

                    const symbolTable = symbolTableManager.getTable(detailPath);
                    symbolTable.setModuleId(file.moduleId);
                    symbolTableManager.registerModule(detailPath, file.moduleId);

                    annotatedFunctions.forEach(func => {
                        symbolTable.registerFunction(func, { autoExport: currentLanguageId === 'python' });
                        functionMapById.set(func.id, func);
                    });

                    (extracted.exports || []).forEach(exp => {
                        if (!exp?.name) return;
                        symbolTable.addExport(exp.name, {
                            isDefault: !!exp.isDefault,
                            localName: exp.localName,
                            kind: exp.kind || 'value'
                        });
                    });

                    (extracted.imports || []).forEach(imp => {
                        if (!imp?.name) return;
                        const resolved = resolveImportModule(file, imp.from, currentLanguageId);
                        symbolTable.addImport(imp.name, {
                            from: imp.from,
                            originalName: imp.originalName,
                            isDefault: !!imp.isDefault,
                            moduleId: resolved?.moduleId || null,
                            resolvedFilePath: resolved?.filePath || null
                        });
                    });

                    extractedFunctionCount += annotatedFunctions.length;
                    extractedCallCount += annotatedCalls.length;

                    if (!largeRepoNotified && extractedFunctionCount >= largeRepoThreshold) {
                        const previewParsed = parsedCount + 1;
                        largeRepoNotified = true;
                        console.info(
                            `[HELIOS parser] Large repository detected: ${extractedFunctionCount.toLocaleString()} functions processed across ${previewParsed.toLocaleString()} files so far.`
                        );
                    }
                } catch (err) {
                    console.error(`Failed to parse ${detailPath}:`, err);
                } finally {
                    parsedCount += 1;
                    updateProgress('Parsing source files...', parsedCount, total, {
                        unit: 'files',
                        detail: buildParsingDetail({
                            functionsCount: extractedFunctionCount,
                            callCount: extractedCallCount,
                            currentFile: detailPath,
                            languageId: currentLanguageId,
                            largeRepo: largeRepoNotified
                        })
                    });
                }
            }

            return {
                parsedFiles: parsedCount,
                functionsExtracted: extractedFunctionCount,
                callsDetected: extractedCallCount,
                largeRepo: largeRepoNotified
            };
        }

        function displayResults() {
            fileList.innerHTML = '';

            sourceFiles.forEach((file, index) => {
                const { path, language } = file;
                const label = languageDisplayNames[language] || language;
                const fileFunctions = allFunctions.filter(f => f.filePath === path);
                
                const fileItem = document.createElement('div');
                fileItem.className = 'file-item';
                fileItem.innerHTML = `
                    <div style="font-weight: 600; margin-bottom: 0.25rem;">${path}</div>
                    <div style="font-size: 0.8rem; opacity: 0.65;">
                        ${label} · ${fileFunctions.length} function${fileFunctions.length !== 1 ? 's' : ''}
                    </div>
                `;
                fileItem.style.animationDelay = `${index * 0.02}s`;
                fileList.appendChild(fileItem);

                fileFunctions.forEach((func, funcIndex) => {
                    const funcItem = document.createElement('div');
                    funcItem.className = 'file-item';
                    funcItem.style.marginLeft = '1rem';
                    funcItem.style.marginTop = '0.5rem';
                    funcItem.style.padding = '0.5rem 0.75rem';
                    funcItem.style.fontSize = '0.85rem';
                    funcItem.innerHTML = `
                        <div style="color: #a5b4fc;">
                            <span style="font-weight: 600;">${func.name}</span>
                            <span style="opacity: 0.6; margin-left: 0.5rem;">(${func.startLine}:${func.startColumn})</span>
                        </div>
                    `;
                    funcItem.style.animationDelay = `${(index * 0.02) + (funcIndex * 0.01)}s`;
                    fileList.appendChild(funcItem);
                });
            });
        }

        async function initializeVisualization() {
            try {
                console.log('[Visualization] Initializing visualization...');
                console.log('[Visualization] callGraph exists:', !!callGraph);
                console.log('[Visualization] callGraph.nodes:', callGraph?.nodes?.length || 0);
                
                if (!callGraph || !callGraph.nodes || callGraph.nodes.length === 0) {
                    console.error('[Visualization] No call graph data available!', {
                        hasCallGraph: !!callGraph,
                        nodesLength: callGraph?.nodes?.length || 0,
                        allFunctionsLength: allFunctions.length
                    });
                    alert('No call graph data available. Please parse a repository first.');
                    return;
                }
                
                console.log('[Visualization] Call graph validated, proceeding with initialization...');

                // Force show viz container
                vizContainer.classList.remove('hidden');
                vizContainer.style.setProperty('display', 'grid', 'important');
                vizContainer.style.setProperty('visibility', 'visible', 'important');
                vizContainer.style.setProperty('opacity', '1', 'important');
                vizContainer.style.setProperty('z-index', '100', 'important');
                
                // EMERGENCY: Force all child elements visible
                const vizGraphEl = document.getElementById('vizGraph');
                const vizSidebarEl = vizContainer.querySelector('.viz-sidebar');
                const vizControlsEl = document.getElementById('vizControls');
                
                if (vizGraphEl) {
                    vizGraphEl.style.display = 'block';
                    vizGraphEl.style.visibility = 'visible';
                    vizGraphEl.style.opacity = '1';
                    vizGraphEl.style.width = '100%';
                    vizGraphEl.style.height = '100%';
                }
                
                if (vizSidebarEl) {
                    vizSidebarEl.style.setProperty('display', 'flex', 'important');
                    vizSidebarEl.style.setProperty('visibility', 'visible', 'important');
                    vizSidebarEl.style.setProperty('opacity', '1', 'important');
                    vizSidebarEl.style.setProperty('width', '360px', 'important');
                    vizSidebarEl.style.setProperty('min-width', '360px', 'important');
                    vizSidebarEl.style.setProperty('max-width', '360px', 'important');
                    console.log('[Visualization] Sidebar forced visible, width:', vizSidebarEl.offsetWidth);
                } else {
                    console.error('[Visualization] ERROR: vizSidebarEl not found!');
                }
                
                if (vizControlsEl) {
                    vizControlsEl.style.setProperty('display', 'block', 'important');
                    vizControlsEl.style.setProperty('visibility', 'visible', 'important');
                    vizControlsEl.style.setProperty('opacity', '1', 'important');
                    console.log('[Visualization] Controls forced visible, has content:', vizControlsEl.innerHTML.length > 0);
                } else {
                    console.error('[Visualization] ERROR: vizControlsEl not found!');
                }
                
                // Also check inspector
                const vizInspectorEl = document.getElementById('vizInspector');
                if (vizInspectorEl) {
                    vizInspectorEl.style.setProperty('display', 'block', 'important');
                    vizInspectorEl.style.setProperty('visibility', 'visible', 'important');
                    vizInspectorEl.style.setProperty('opacity', '1', 'important');
                }
                
                // Ensure close button is visible and clickable
                if (vizCloseBtn) {
                    vizCloseBtn.style.setProperty('display', 'block', 'important');
                    vizCloseBtn.style.setProperty('visibility', 'visible', 'important');
                    vizCloseBtn.style.setProperty('opacity', '1', 'important');
                    vizCloseBtn.style.setProperty('z-index', '200', 'important');
                    vizCloseBtn.style.setProperty('pointer-events', 'auto', 'important');
                    console.log('[Visualization] Close button forced visible');
                } else {
                    console.error('[Visualization] ERROR: vizCloseBtn not found during initialization!');
                }
                
                console.log('[Visualization] Container state:', {
                    containerVisible: !vizContainer.classList.contains('hidden'),
                    containerDisplay: window.getComputedStyle(vizContainer).display,
                    containerWidth: vizContainer.offsetWidth,
                    containerHeight: vizContainer.offsetHeight,
                    hasVizGraph: !!vizGraphEl,
                    vizGraphWidth: vizGraphEl?.offsetWidth,
                    vizGraphHeight: vizGraphEl?.offsetHeight,
                    hasSidebar: !!vizSidebarEl,
                    sidebarWidth: vizSidebarEl?.offsetWidth,
                    hasControls: !!vizControlsEl,
                    hasCanvas: !!vizGraphEl?.querySelector('canvas')
                });
                
                // Hide hero container when showing visualization
                // Only hide if we successfully got past validation
                const heroContainer = document.querySelector('.hero-container');
                if (heroContainer) {
                    heroContainer.classList.add('hidden');
                    heroContainer.style.display = 'none';
                }
                
                // Also hide results container (but only after validation passes)
                // This way if there's an error earlier, the button stays visible
                if (resultsContainer) {
                    resultsContainer.classList.add('hidden');
                    resultsContainer.style.display = 'none';
                }

                // Always create a fresh GraphVisualization instance to avoid state pollution
                // between different repos/demos
                if (graphViz) {
                    console.log('[Visualization] Disposing existing GraphVisualization instance...');
                    try {
                        graphViz.dispose?.();
                    } catch (err) {
                        console.warn('[Visualization] Error disposing existing graphViz:', err);
                    }
                    graphViz = null;
                }
                
                console.log('[Visualization] Creating GraphVisualization instance...');
                if (!vizGraph) {
                    console.error('[Visualization] ERROR: vizGraph element not found!');
                    alert('Error: Graph container element not found!');
                    return;
                }
                graphViz = new GraphVisualization(vizGraph);
                console.log('[Visualization] Initializing GraphVisualization...');
                await graphViz.initialize();
                graphViz.onNodeClick = handleNodeClick;
                graphViz.onNodeHover = handleNodeHover;
                graphViz.onFilterChange = applyVisualizationFilters;
                console.log('[Visualization] GraphVisualization initialized');

            // Always create fresh inspector and controls to avoid state pollution
            if (inspector) {
                try {
                    inspector.hide?.();
                    inspector = null;
                } catch (err) {
                    console.warn('[Visualization] Error disposing inspector:', err);
                }
            }
            inspector = new InspectorPanel(vizInspector);

            if (controls) {
                try {
                    controls = null;
                } catch (err) {
                    console.warn('[Visualization] Error disposing controls:', err);
                }
            }
            
            if (vizControls) {
                    console.log('[Visualization] Creating VisualizationControls...');
                    console.log('[Visualization] vizControls element:', {
                        exists: !!vizControls,
                        display: window.getComputedStyle(vizControls).display,
                        visibility: window.getComputedStyle(vizControls).visibility,
                        width: vizControls.offsetWidth,
                        height: vizControls.offsetHeight,
                        innerHTML: vizControls.innerHTML.length
                    });
                    controls = new VisualizationControls(vizControls, graphViz);
                    if (typeof controls.setEmbeddingSummary === 'function') {
                        controls.setEmbeddingSummary(latestEmbeddingSummary || null);
                    }
                    console.log('[Visualization] VisualizationControls created, container has content:', vizControls.innerHTML.length > 0);
                    
                    // Force sidebar visible again after controls are created
                    const sidebar = vizContainer.querySelector('.viz-sidebar');
                    if (sidebar) {
                        sidebar.style.setProperty('display', 'flex', 'important');
                        sidebar.style.setProperty('visibility', 'visible', 'important');
                        sidebar.style.setProperty('opacity', '1', 'important');
                        sidebar.style.setProperty('width', '360px', 'important');
                        console.log('[Visualization] Sidebar re-checked after controls creation, width:', sidebar.offsetWidth);
                    }
                } else if (!vizControls) {
                    console.error('[Visualization] ERROR: vizControls element not found!');
                } else if (controls) {
                    console.log('[Visualization] VisualizationControls already exists, reusing');
                }

            graphViz.onHoverDetails = (info) => {
                if (controls && typeof controls.setHoverInfo === 'function') {
                    controls.setHoverInfo(info);
                }
            };
            graphViz.onAnalysisSummary = (summary) => {
                if (controls && typeof controls.setAnalysisSummary === 'function') {
                    controls.setAnalysisSummary(summary);
                }
            };

            if (graphViz && typeof graphViz.setAnalysisSummary === 'function') {
                graphViz.setAnalysisSummary(window.heliosGraphSummary || null);
            }

            if (inspector) {
                inspector.onNavigate = (nodeId) => {
                    graphViz.focusNodeById(nodeId);
                };
            }

            const functionLookup = new Map((allFunctions || []).map(fn => [fn.id, fn]));
            (graphSerialized?.nodes || []).forEach(node => {
                if (!functionLookup.has(node.id)) {
                    const range = node.range || {};
                    functionLookup.set(node.id, {
                        id: node.id,
                        name: node.name || node.fqName || node.id,
                        fqName: node.fqName || node.name || node.id,
                        filePath: node.filePath || null,
                        moduleId: node.moduleId || null,
                        lang: node.lang || detectLanguageFromPath(node.filePath || ''),
                        startLine: range.startLine ?? node.startLine ?? null,
                        endLine: range.endLine ?? node.endLine ?? null,
                        startColumn: range.startColumn ?? node.startColumn ?? null,
                        endColumn: range.endColumn ?? node.endColumn ?? null,
                        doc: node.doc || '',
                        source: node.source || ''
                    });
                }
            });
            functionMapById = functionLookup;
            const hasAnalyzedGraph = Array.isArray(graphSerialized?.nodes) && graphSerialized.nodes.length > 0;
            fullVizData = convertCallGraphToVizData(
                hasAnalyzedGraph ? graphSerialized : callGraph,
                { includeFallbackSimilarity: !hasAnalyzedGraph }
            );
            const layoutKey = computeLayoutStorageKey(callGraph);
            const layoutHash = extractLayoutHash(layoutKey);
            graphViz.setLayoutStorageKey(layoutKey, layoutHash);

            if (await ensureStorageClient()) {
                const provider = createLayoutPersistenceProvider(layoutKey, layoutHash);
                graphViz.setLayoutStorageProvider(provider);
            } else {
                graphViz.setLayoutStorageProvider(null);
            }

            console.log('[Visualization] Preparing visualization data...');
            
            if (!fullVizData || !fullVizData.nodes || fullVizData.nodes.length === 0) {
                console.error('[Visualization] ERROR: No visualization data available!', { 
                    nodes: fullVizData?.nodes?.length || 0, 
                    callGraphNodes: callGraph?.nodes?.length || 0 
                });
                alert('No graph data available to visualize. Please ensure parsing completed successfully.');
                return;
            }
            
            const initialFilters = controls ? controls.getFilters() : {};
            console.log('[Visualization] Calling applyVisualizationFilters with', fullVizData.nodes.length, 'nodes');
            applyVisualizationFilters(initialFilters);
            console.log('[Visualization] Filters applied, data loaded to graph');

            console.log('[Visualization] Restoring layout...');
            const restored = await graphViz.restoreLayoutFromStorage({ freeze: true });
            const loadInfo = graphViz.getLastLayoutLoadResult
                ? graphViz.getLastLayoutLoadResult()
                : null;

            if (controls && typeof controls.setLayoutStatus === 'function') {
                const { message, tone, timeout } = describeLayoutStatus(loadInfo, restored);
                controls.setLayoutStatus(message, {
                    tone,
                    timeout: tone === 'success' ? undefined : timeout ?? 5000
                });
            }

            console.log('[Visualization] Fitting to view...');
            if (!restored) {
                setTimeout(() => graphViz.fitToView(), 400);
            } else {
                graphViz.fitToView();
            }
            
            console.log('[Visualization] Initialization complete');
            } catch (error) {
                console.error('[Visualization] Failed to initialize visualization:', error);
                console.error('[Visualization] Error details:', error?.stack || error);
                
                // Restore results container and visualize button if initialization failed
                // This allows the user to retry
                if (resultsContainer) {
                    resultsContainer.classList.remove('hidden');
                    resultsContainer.style.display = 'block';
                    resultsContainer.style.visibility = 'visible';
                }
                if (visualizeBtn) {
                    visualizeBtn.classList.remove('hidden');
                    visualizeBtn.style.display = 'block';
                    visualizeBtn.style.visibility = 'visible';
                    visualizeBtn.style.opacity = '1';
                }
                
                // Restore hero container too
                const heroContainer = document.querySelector('.hero-container');
                if (heroContainer) {
                    heroContainer.classList.remove('hidden');
                    heroContainer.style.display = 'flex';
                }
                
                // Hide viz container
                vizContainer.classList.add('hidden');
                vizContainer.style.setProperty('display', 'none', 'important');
                
                alert(`Failed to initialize visualization: ${error.message || error}. Check console for details.\n\nYou can click "Visualize Graph" to retry.`);
                throw error; // Re-throw so caller knows it failed
            }
        }

        function groupFilesByLanguage(files) {
            return files.reduce((acc, file) => {
                const lang = file.language || detectLanguageFromPath(file.path || '');
                if (!acc[lang]) acc[lang] = [];
                acc[lang].push(file);
                return acc;
            }, {});
        }

        function getExtractorForLanguage(languageId) {
            switch (languageId) {
                case 'javascript':
                case 'typescript':
                case 'jsx':
                case 'tsx':
                    return extractJavaScript;
                case 'python':
                    return extractPython;
                default:
                    return null;
            }
        }

        function annotateFunctions(functions = [], languageId, moduleId = null) {
            return (functions || []).map(fn => {
                const resolvedModuleId = fn.moduleId || moduleId || null;
                return {
                    ...fn,
                    lang: fn.lang || languageId,
                    moduleId: resolvedModuleId,
                    fqName: fn.fqName || buildFunctionFqName(resolvedModuleId, fn.name)
                };
            });
        }

        function annotateCalls(calls = [], languageId) {
            return (calls || []).map(call => ({
                ...call,
                language: call.language || languageId
            }));
        }

        function getExtension(fileName = '') {
            const index = fileName.lastIndexOf('.');
            return index >= 0 ? fileName.slice(index).toLowerCase() : '';
        }

        function formatCounterMessage() {
            if (!sourceFiles.length) {
                return 'No source files processed yet';
            }

            const counts = groupFilesByLanguage(sourceFiles);
            const parts = Object.entries(counts)
                .filter(([, files]) => files.length > 0)
                .map(([lang, files]) => `${files.length} ${(languageDisplayNames[lang] || lang)} file${files.length !== 1 ? 's' : ''}`);

            return `Found ${sourceFiles.length} source file${sourceFiles.length !== 1 ? 's' : ''}${parts.length ? ' (' + parts.join(', ') + ')' : ''}`;
        }

        function exportSymbolTables(manager) {
            if (!manager || typeof manager.getAllTables !== 'function') {
                return null;
            }
            const tables = manager.getAllTables();
            if (!tables || typeof tables.forEach !== 'function') {
                return null;
            }
            const result = {};
            tables.forEach((table, filePath) => {
                if (!table) {
                    return;
                }
                const symbolEntries = table.symbols instanceof Map
                    ? Array.from(table.symbols.entries()).map(([local, fullyQualifiedName]) => ({
                        local,
                        fullyQualifiedName
                    }))
                    : [];
                const functionEntries = typeof table.getAllFunctions === 'function'
                    ? table.getAllFunctions()
                    : table.functions instanceof Map
                        ? Array.from(table.functions.values())
                        : [];
                result[filePath] = {
                    moduleId: typeof table.getModuleId === 'function'
                        ? table.getModuleId()
                        : table.moduleId ?? null,
                    exports: typeof table.getExports === 'function' ? table.getExports() : [],
                    imports: typeof table.getImports === 'function' ? table.getImports() : [],
                    symbols: symbolEntries,
                    functions: functionEntries
                };
            });
            return result;
        }

        async function updateGraphData(input = {}) {
            const hasLegacyShape =
                input && !input.parser && !input.embeddings && (input.functions || input.callEdges || input.similarityEdges);

            const overrides = input.overrides || (hasLegacyShape ? input : {});
            const parserInput = input.parser || {};
            const embeddingInput = input.embeddings || {};

            const parserPayload = {
                functions: Array.isArray(parserInput.functions)
                    ? parserInput.functions
                    : Array.isArray(callGraph?.nodes)
                        ? callGraph.nodes
                        : Array.isArray(allFunctions)
                            ? allFunctions
                            : [],
                callEdges: Array.isArray(parserInput.callEdges)
                    ? parserInput.callEdges
                    : Array.isArray(callGraph?.edges)
                        ? callGraph.edges
                        : [],
                stats: parserInput.stats || callGraph?.stats || null,
                symbolTables: parserInput.symbolTables || exportSymbolTables(symbolTableManager)
            };

            const embeddingPayload = {
                similarityEdges: Array.isArray(embeddingInput.similarityEdges)
                    ? embeddingInput.similarityEdges
                    : Array.isArray(similarityEdges)
                        ? similarityEdges
                        : [],
                metadata: embeddingInput.metadata || embeddingMetadata || null,
                stats: embeddingInput.stats || similarityStats || null
            };

            if (Array.isArray(functionEmbeddings) && functionEmbeddings.length) {
                embeddingPayload.functionEmbeddings = functionEmbeddings;
            }

            const mergedPayload = mergeGraphPayload({
                parser: parserPayload,
                embeddings: embeddingPayload,
                overrides
            });

            graphPayload = mergedPayload;
            graphExtras = mergedPayload.extras || null;

            let analysisResult = null;
            let collected = null;
            try {
                analysisResult = await graphWorkerClient.analyze(mergedPayload, { assignMetrics: true });
                collected = analysisResult.collected || collectGraphPayload(mergedPayload);

                graphAnalysis = analysisResult.graph || null;
                graphSummary = analysisResult.summary || null;
                graphSerialized = analysisResult.serialized || { nodes: [], edges: [] };

                window.heliosGraph = graphAnalysis;
                window.heliosGraphSummary = graphSummary;
                window.heliosGraphSerialized = graphSerialized;
                window.heliosGraphPayload = mergedPayload;
                window.heliosGraphExtras = graphExtras;
                window.heliosCallEdges = collected.callEdges || [];
                window.heliosSimilarityEdges = collected.similarityEdges || [];
                window.heliosGraphStats = graphSummary;
                window.heliosGraphWorkerMode = analysisResult?.viaWorker ? 'worker' : 'inline';
                window.heliosGraphValidation = analysisResult?.validation || null;

                fullVizData = convertCallGraphToVizData(graphSerialized, { includeFallbackSimilarity: false });
            } catch (err) {
                console.error('Graph analysis failed:', err);
                graphAnalysis = null;
                graphSummary = null;
                graphSerialized = { nodes: [], edges: [] };
                collected = collectGraphPayload(mergedPayload);

                window.heliosGraph = null;
                window.heliosGraphSummary = null;
                window.heliosGraphSerialized = graphSerialized;
                window.heliosGraphPayload = mergedPayload;
                window.heliosGraphExtras = graphExtras;
                window.heliosCallEdges = collected.callEdges || [];
                window.heliosSimilarityEdges = collected.similarityEdges || [];
                window.heliosGraphStats = null;
                window.heliosGraphWorkerMode = 'error';
                window.heliosGraphValidation = null;

                fullVizData = convertCallGraphToVizData(
                    {
                        nodes: parserPayload.functions || [],
                        edges: collected.callEdges || []
                    },
                    { includeFallbackSimilarity: true }
                );
            }
            if (graphViz && typeof graphViz.setAnalysisSummary === 'function') {
                graphViz.setAnalysisSummary(graphSummary);
            }

            return {
                payload: mergedPayload,
                extras: graphExtras,
                summary: graphSummary,
                serialized: graphSerialized,
                collected,
                viaWorker: analysisResult?.viaWorker === true
            };
        }

        function convertCallGraphToVizData(graph, { includeFallbackSimilarity = true } = {}) {
            if (!graph) return { nodes: [], links: [] };

            const nodes = (graph.nodes || []).map(fn => {
                const range = fn.range || {};
                const startLine = fn.startLine ?? range.startLine ?? null;
                const endLine = fn.endLine ?? range.endLine ?? null;
                const startColumn = fn.startColumn ?? range.startColumn ?? null;
                const endColumn = fn.endColumn ?? range.endColumn ?? null;
                const locEstimate = (() => {
                    const start = startLine ?? 0;
                    const end = endLine ?? start;
                    return Math.max(1, end - start + 1);
                })();

                return {
                    id: fn.id,
                    fqName: fn.fqName || fn.name || fn.id,
                    name: fn.name || fn.fqName || fn.id,
                    filePath: fn.filePath,
                    lang: fn.lang || detectLanguageFromPath(fn.filePath),
                    moduleId: fn.moduleId || null,
                    isVirtual: !!fn.isVirtual,
                    size: fn.loc || locEstimate,
                    startLine,
                    endLine,
                    startColumn,
                    endColumn,
                    doc: fn.doc || '',
                    metrics: fn.metrics || {},
                    analysis: fn.analysis || null,
                    source: fn.source || ''
                };
            });

            const links = [];
            let hasSimilarityEdges = false;

            (graph.edges || []).forEach(edge => {
                const layer = (edge.layer || edge.type || '').toLowerCase();
                const isSimilarity =
                    layer === 'similarity' ||
                    (!!edge.undirected && layer !== 'call') ||
                    (layer !== 'call' && typeof edge.similarity === 'number');

                if (isSimilarity) {
                    hasSimilarityEdges = true;
                    links.push({
                        source: edge.source,
                        target: edge.target,
                        type: 'similarity',
                        weight: Number.isFinite(edge.similarity)
                            ? edge.similarity
                            : edge.representativeSimilarity ?? 0,
                        similarity: Number.isFinite(edge.similarity) ? edge.similarity : 0,
                        method: edge.method || edge.metadata?.method || 'topk-avg',
                        representativeSimilarity: edge.representativeSimilarity ?? null,
                        topPairs: edge.topPairs || edge.metadata?.topPairs || [],
                        undirected: edge.undirected ?? true,
                        metadata: edge.metadata || null
                    });
                    return;
                }

                const metadata = edge.metadata || {};
                const resolution = edge.resolution || metadata.resolution || null;
                const resolutionStatus = resolution?.status || 'resolved';

                links.push({
                    source: edge.source,
                    target: edge.target,
                    type: 'call',
                    weight: Number.isFinite(edge.weight) ? Number(edge.weight) : 1,
                    dynamic: !!edge.isDynamic,
                    resolution,
                    resolutionStatus,
                    resolutionReason: resolution?.reason || '',
                    importInfo: resolution?.importInfo || metadata.importInfo || null,
                    metadata,
                    callSites: edge.callSites || metadata.callSites || metadata.callSiteSamples || null
                });
            });

            if (includeFallbackSimilarity && !hasSimilarityEdges && similarityEdges.length > 0) {
                similarityEdges.forEach(edge => {
                    links.push({
                        source: edge.source,
                        target: edge.target,
                        type: 'similarity',
                        weight: edge.similarity || edge.representativeSimilarity || 0,
                        similarity: edge.similarity || 0,
                        method: edge.method || 'topk-avg',
                        representativeSimilarity: edge.representativeSimilarity ?? null,
                        topPairs: edge.topPairs || [],
                        undirected: true
                    });
                });
            }

            return { nodes, links };
        }

        function detectLanguageFromPath(path = '') {
            const ext = getExtension(path);
            switch (ext) {
                case '.ts':
                case '.tsx':
                    return 'typescript';
                case '.jsx':
                    return 'jsx';
                case '.py':
                    return 'python';
                default:
                    return 'javascript';
            }
        }

        function applyVisualizationFilters(filters = {}) {
            console.log('[applyVisualizationFilters] Called with filters:', filters);
            console.log('[applyVisualizationFilters] graphViz exists:', !!graphViz, 'fullVizData exists:', !!fullVizData);
            
            if (!graphViz || !fullVizData) {
                console.error('[applyVisualizationFilters] ERROR: Missing graphViz or fullVizData!', {
                    hasGraphViz: !!graphViz,
                    hasFullVizData: !!fullVizData,
                    fullVizDataNodes: fullVizData?.nodes?.length || 0
                });
                return;
            }
            
            console.log('[applyVisualizationFilters] fullVizData has', fullVizData.nodes.length, 'nodes and', fullVizData.links.length, 'links');
            
            // Verify data structure
            if (!Array.isArray(fullVizData.nodes)) {
                console.error('[applyVisualizationFilters] ERROR: fullVizData.nodes is not an array!', typeof fullVizData.nodes, fullVizData);
                return;
            }
            if (!Array.isArray(fullVizData.links)) {
                console.error('[applyVisualizationFilters] ERROR: fullVizData.links is not an array!', typeof fullVizData.links, fullVizData);
                return;
            }

            try {
                const moduleFilter = filters.module?.toLowerCase() || filters.folder?.toLowerCase() || '';
                const languageFilter = filters.language || '';
                const minSize = Number.isFinite(filters.minSize) ? filters.minSize : 0;
                const maxSize = Number.isFinite(filters.maxSize) ? filters.maxSize : Infinity;

                console.log('[applyVisualizationFilters] Filter params:', { moduleFilter, languageFilter, minSize, maxSize });

                const filteredNodes = fullVizData.nodes.filter(node => {
                    try {
                        if (moduleFilter && !(node.filePath || '').toLowerCase().includes(moduleFilter)) {
                            return false;
                        }
                        if (languageFilter && node.lang !== languageFilter) {
                            return false;
                        }
                        if (node.size < minSize) {
                            return false;
                        }
                        if (Number.isFinite(maxSize) && node.size > maxSize) {
                            return false;
                        }
                        return true;
                    } catch (nodeErr) {
                        console.error('[applyVisualizationFilters] Error filtering node:', node, nodeErr);
                        return false;
                    }
                });

                console.log('[applyVisualizationFilters] Filtered nodes:', filteredNodes.length, 'out of', fullVizData.nodes.length);

                const allowedIds = new Set(filteredNodes.map(node => node.id));
                console.log('[applyVisualizationFilters] Allowed node IDs:', Array.from(allowedIds));

                const filteredLinks = fullVizData.links.filter(link => {
                    const sourceId = link.sourceId || link.source;
                    const targetId = link.targetId || link.target;
                    return allowedIds.has(sourceId) && allowedIds.has(targetId);
                });

                console.log('[applyVisualizationFilters] Filtered to', filteredNodes.length, 'nodes and', filteredLinks.length, 'links');
                console.log('[applyVisualizationFilters] Calling graphViz.loadData...');
                
                if (!graphViz || typeof graphViz.loadData !== 'function') {
                    throw new Error('graphViz.loadData is not a function! graphViz:', graphViz);
                }

                graphViz.loadData({ nodes: filteredNodes, links: filteredLinks });
                console.log('[applyVisualizationFilters] loadData() completed successfully');
            } catch (err) {
                console.error('[applyVisualizationFilters] ERROR:', err);
                console.error('[applyVisualizationFilters] Stack:', err.stack);
                alert('ERROR: Failed to apply visualization filters: ' + (err.message || err));
                throw err;
            }
        }

        async function handleNodeClick(node, edgeSummary) {
            if (!node) {
                inspector?.hide();
                return;
            }
            const source = await getFunctionSource(node);
            inspector?.show(node, source, edgeSummary);
        }

        function handleNodeHover(node) {
            // Future enhancements: display hover details in sidebar
        }

        async function getFunctionSource(node) {
            const original = functionMapById.get(node.id);
            if (original?.source) {
                return original.source;
            }

            const filePath = original?.filePath || node.filePath;
            if (!filePath || !fileHandles.has(filePath)) {
                return '';
            }

            try {
                const fileHandle = fileHandles.get(filePath);
                const file = await fileHandle.getFile();
                const source = await file.text();
                if (original?.startLine && original?.endLine) {
                    const lines = source.split('\n');
                    const slice = lines.slice(original.startLine - 1, original.endLine).join('\n');
                    return slice;
                }
                return source;
            } catch (err) {
                console.error('Failed to read function source', err);
                return '';
            }
        }

        function buildFunctionFqName(moduleId, name) {
            if (!name) {
                return name;
            }
            if (!moduleId) {
                return name;
            }
            return `${moduleId}.${name}`;
        }

        function registerSourceFile(fileMeta) {
            if (!fileMeta || !fileMeta.path) {
                return;
            }

            const normalized = {
                ...fileMeta,
                path: normalizeSlashes(fileMeta.path)
            };

            sourceFileIndex.set(normalized.path, normalized);

            if (normalized.moduleId) {
                const entry = ensureModuleIndexEntry(normalized.moduleId);
                entry.files.add(normalized.path);
                (normalized.moduleAliases || []).forEach(alias => {
                    if (alias) {
                        entry.aliases.add(alias);
                    }
                });
            }
        }

        function ensureModuleIndexEntry(moduleId) {
            if (!moduleId) {
                return { files: new Set(), aliases: new Set() };
            }
            if (!moduleIndex.has(moduleId)) {
                moduleIndex.set(moduleId, { files: new Set(), aliases: new Set([moduleId]) });
            }
            return moduleIndex.get(moduleId);
        }

        function createModuleMetadata(filePath, languageId) {
            const normalizedPath = normalizeSlashes(filePath);
            const fileName = normalizedPath.split('/').pop() || '';
            const dirName = getDirname(normalizedPath);
            const lowerFileName = fileName.toLowerCase();
            const aliases = new Set();

            let moduleId = stripExtension(normalizedPath);
            const isJavaScriptLike = ['javascript', 'typescript', 'jsx', 'tsx'].includes(languageId);

            if (isJavaScriptLike) {
                if (JS_INDEX_FILENAMES.includes(lowerFileName)) {
                    moduleId = dirName || moduleId;
                }
                aliases.add(normalizeSlashes(moduleId));
                aliases.add(stripExtension(fileName));
            } else if (languageId === 'python') {
                if (PY_PACKAGE_FILENAMES.includes(lowerFileName)) {
                    moduleId = dirName;
                }
                const dotted = (moduleId || '').replace(/\//g, '.').replace(/^\.+/, '');
                const packageAlias = (dirName || '').replace(/\//g, '.').replace(/^\.+/, '');
                if (dotted) aliases.add(dotted);
                if (packageAlias) aliases.add(packageAlias);
                if (moduleId) aliases.add(moduleId);
            } else {
                aliases.add(moduleId);
            }

            const aliasList = Array.from(aliases).filter(Boolean);

            return {
                moduleId: moduleId || normalizedPath,
                aliases: aliasList
            };
        }

        function normalizeSlashes(path = '') {
            return path.replace(/\\/g, '/');
        }

        function stripExtension(path = '') {
            const normalized = normalizeSlashes(path);
            const lastDot = normalized.lastIndexOf('.');
            if (lastDot <= normalized.lastIndexOf('/')) {
                return normalized;
            }
            return normalized.slice(0, lastDot);
        }

        function getDirname(path = '') {
            const normalized = normalizeSlashes(path);
            const idx = normalized.lastIndexOf('/');
            if (idx === -1) {
                return '';
            }
            return normalized.slice(0, idx);
        }

        function resolveRelativePath(fromPath, specifier) {
            const fromDir = getDirname(fromPath);
            const segments = fromDir ? fromDir.split('/') : [];
            const specSegments = normalizeSlashes(specifier).split('/');

            for (const segment of specSegments) {
                if (!segment || segment === '.') {
                    continue;
                }
                if (segment === '..') {
                    if (segments.length) {
                        segments.pop();
                    }
                } else {
                    segments.push(segment);
                }
            }

            return segments.join('/');
        }

        function enumeratePossibleModuleFiles(basePath, languageId) {
            const possibilities = [];
            const baseWithoutExt = stripExtension(basePath);

            if (['javascript', 'typescript', 'jsx', 'tsx'].includes(languageId)) {
                JS_FILE_EXTENSIONS.forEach(ext => {
                    possibilities.push(`${baseWithoutExt}${ext}`);
                });
                JS_FILE_EXTENSIONS.forEach(ext => {
                    possibilities.push(`${baseWithoutExt}/index${ext}`);
                });
            } else if (languageId === 'python') {
                possibilities.push(`${baseWithoutExt}.py`);
                possibilities.push(`${baseWithoutExt}/__init__.py`);
            } else {
                possibilities.push(basePath);
            }

            return Array.from(new Set(possibilities.map(normalizeSlashes)));
        }

        function resolveImportModule(fileMeta, specifier, languageId) {
            if (!specifier) {
                return null;
            }

            const normalizedSpec = normalizeSlashes(specifier);

            const trySourceFile = (candidatePath) => {
                const meta = sourceFileIndex.get(candidatePath);
                if (meta) {
                    return {
                        moduleId: meta.moduleId || null,
                        filePath: meta.path
                    };
                }
                return null;
            };

            if (normalizedSpec.startsWith('.')) {
                const basePath = resolveRelativePath(fileMeta.path, normalizedSpec);
                const candidates = enumeratePossibleModuleFiles(basePath, languageId);
                for (const candidate of candidates) {
                    const resolved = trySourceFile(candidate);
                    if (resolved) {
                        return resolved;
                    }
                }
            } else {
                for (const [moduleId, entry] of moduleIndex.entries()) {
                    if (moduleId === normalizedSpec || entry.aliases.has(normalizedSpec)) {
                        const files = Array.from(entry.files);
                        if (files.length) {
                            return {
                                moduleId,
                                filePath: files[0]
                            };
                        }
                    }
                }

                if (languageId === 'python') {
                    const candidateBase = normalizedSpec.replace(/\./g, '/');
                    const candidates = enumeratePossibleModuleFiles(candidateBase, languageId);
                    for (const candidate of candidates) {
                        const resolved = trySourceFile(candidate);
                        if (resolved) {
                            return resolved;
                        }
                    }
                }
            }

            return null;
        }

        async function ensureStorageClient() {
            if (storageReady && storageClient) {
                if (clearStorageBtn) {
                    clearStorageBtn.disabled = false;
                    if (exportDbBtn) {
                        exportDbBtn.disabled = false;
                    }
                }
                if (storagePersistent === true) {
                    setStorageStatus('Storage ready (OPFS persistent).', 'success');
                } else if (storagePersistent === false) {
                    setStorageStatus(STORAGE_FALLBACK_MESSAGE, 'warning');
                }
                return true;
            }
            if (storageClientInitPromise) {
                return storageClientInitPromise;
            }
            storageClientInitPromise = (async () => {
                try {
                    const client = new StorageWorkerClient({
                        initConfig: {
                            retention: { enabled: true }  // Enable retention cleanup (24h default)
                        }
                    });
                    const initResult = await client.ensureInitialized();
                    
                    // Check data compatibility after initialization
                    try {
                        const { checkDataCompatibility, shouldInvalidateData } = await import('./src/storage/data-compatibility.js');
                        const compatibility = await checkDataCompatibility(client);
                        
                        if (!compatibility.compatible || shouldInvalidateData(compatibility, false)) {
                            console.warn('[Storage] Data compatibility check failed:', compatibility.issues);
                            console.info('[Storage] Consider clearing stored data if you experience issues.');
                            
                            if (compatibility.issues.length > 0) {
                                // Log but don't block - app can work with stale data
                                // User can clear storage if they encounter issues
                                console.info('[Storage] Compatibility issues detected:', compatibility.issues);
                            }
                        } else {
                            console.debug('[Storage] Data compatibility check passed');
                        }
                    } catch (compatErr) {
                        // Compatibility check failed - not critical, log and continue
                        console.debug('[Storage] Compatibility check unavailable:', compatErr?.message || compatErr);
                    }
                    
                    storageClient = client;
                    storageReady = true;
                    storagePersistent = initResult?.persistent === true;
                    if (clearStorageBtn) {
                        clearStorageBtn.disabled = false;
                    }
                    if (exportDbBtn) {
                        exportDbBtn.disabled = false;
                    }
                    if (storagePersistent) {
                        setStorageStatus('Storage ready (OPFS persistent).', 'success');
                    } else {
                        setStorageStatus(STORAGE_FALLBACK_MESSAGE, 'warning');
                    }
                    return true;
                } catch (err) {
                    console.warn('Storage worker unavailable; falling back to browser storage.', err);
                    // Graceful degradation - app works without storage
                    storageClient = null;
                    storageReady = false;
                    storagePersistent = null;
                    if (clearStorageBtn) {
                        clearStorageBtn.disabled = true;
                    }
                    setStorageStatus('Storage unavailable; using memory mode (data won\'t persist).', 'warning');
                    // Don't return false - app can work in memory mode
                    return true; // Changed to true for graceful degradation
                } finally {
                    storageClientInitPromise = null;
                }
            })();
            return storageClientInitPromise;
        }

        async function initializeResumeOption() {
            if (!resumeBtn) {
                return;
            }
            resumeBtn.classList.add('hidden');
            resumeSnapshot = null;
            try {
                const available = await ensureStorageClient();
                if (!available || !storageClient) {
                    return;
                }
                const snapshot = await loadAnalysisSnapshot(storageClient);
                if (snapshot && Array.isArray(snapshot.callGraph?.nodes) && snapshot.callGraph.nodes.length) {
                    resumeSnapshot = snapshot;
                    resumeBtn.classList.remove('hidden');
                    setStorageStatus('Saved session detected. Use “Resume Last Session” to continue.', 'info');
                }
            } catch (err) {
                console.warn('Failed to load resume snapshot:', err);
            }
        }

        async function hydrateFromSnapshot(snapshot) {
            if (!snapshot || !snapshot.callGraph) {
                return;
            }

            sourceFiles = Array.isArray(snapshot.sourceFiles)
                ? snapshot.sourceFiles.map(file => ({
                    path: file.path || '',
                    language: file.language || null,
                    moduleId: file.moduleId || null,
                    moduleAliases: Array.isArray(file.moduleAliases) ? [...file.moduleAliases] : []
                }))
                : [];
            fileHandles.clear();
            sourceFileIndex.clear();
            moduleIndex.clear();
            sourceFiles.forEach(registerSourceFile);

            allFunctions = Array.isArray(snapshot.functions)
                ? snapshot.functions.map(fn => ({ ...fn }))
                : [];
            allCalls = [];

            const callGraphNodes = Array.isArray(snapshot.callGraph?.nodes)
                ? snapshot.callGraph.nodes.map(node => ({ ...node }))
                : [];
            const callGraphEdges = Array.isArray(snapshot.callGraph?.edges)
                ? snapshot.callGraph.edges.map(edge => ({
                    ...edge,
                    metadata: edge.metadata ? { ...edge.metadata } : null
                }))
                : [];
            callGraph = {
                nodes: callGraphNodes,
                edges: callGraphEdges,
                stats: snapshot.callGraph?.stats || {
                    totalEdges: callGraphEdges.length,
                    staticEdges: 0,
                    dynamicEdges: 0,
                    resolvedEdges: 0,
                    ambiguousEdges: 0,
                    unresolvedEdges: 0
                }
            };

            similarityEdges = Array.isArray(snapshot.similarityEdges)
                ? snapshot.similarityEdges.map(edge => ({ ...edge }))
                : [];

            embeddingMetadata = snapshot.embedding?.metadata
                ? { ...snapshot.embedding.metadata }
                : {
                    backend: null,
                    modelId: null,
                    dimension: null,
                    quantized: null
                };
            embeddingReuseCounts = snapshot.embedding?.reuse
                ? { ...snapshot.embedding.reuse }
                : { reused: 0, embedded: 0 };
            embeddingStats = snapshot.embedding?.stats || null;
            usedCachedEmbeddings = !!snapshot.embedding?.cached;
            embeddingFingerprint = snapshot.fingerprint || null;
            latestFunctionFingerprintMap = snapshot.functionFingerprints || null;
            embeddingError = snapshot.embedding?.error || null;

            embeddingChunks = [];
            embeddingVectors = [];
            functionEmbeddings = [];

            window.heliosFunctions = allFunctions;
            window.heliosCallGraph = callGraph;
            window.heliosSimilarity = similarityEdges;
            window.heliosEmbeddingReuse = embeddingReuseCounts;
            window.heliosEmbeddingStats = embeddingStats;
            window.heliosEmbeddingError = embeddingError;

            await updateGraphData({
                parser: {
                    functions: allFunctions,
                    callEdges: Array.isArray(callGraph?.edges) ? callGraph.edges : [],
                    stats: callGraph?.stats || null,
                    symbolTables: exportSymbolTables(symbolTableManager)
                },
                embeddings: {
                    similarityEdges: Array.isArray(similarityEdges) ? similarityEdges : [],
                    metadata: embeddingMetadata || null,
                    stats: similarityStats || null,
                    functionEmbeddings: Array.isArray(functionEmbeddings) && functionEmbeddings.length > 0 ? functionEmbeddings : undefined
                }
            });

            if (embeddingEnvironment.detected && embeddingMetadata.backend) {
                embeddingEnvironment = {
                    ...embeddingEnvironment,
                    backend: embeddingMetadata.backend
                };
                embeddingEnvironmentSummary = buildEmbeddingDetectionSummary(embeddingEnvironment);
                window.heliosEmbeddingEnvironment = embeddingEnvironment;
            }

            updateEmbeddingSummary({
                chunkCount: snapshot.embedding?.chunkCount ?? null,
                metadata: embeddingMetadata,
                reuse: embeddingReuseCounts,
                cached: usedCachedEmbeddings,
                similarityEdges: similarityEdges.length,
                functionsWithEmbeddings: allFunctions.length,
                error: embeddingError,
                detection: embeddingEnvironment.detected
                    ? {
                        detected: true,
                        backend: embeddingEnvironment.backend,
                        webgpuAvailable: Boolean(embeddingEnvironment.webgpuAvailable),
                        forced: Boolean(embeddingEnvironment.forced),
                        error: embeddingEnvironment.error
                    }
                    : null
            });

            totalFiles = sourceFiles.length;
            scannedFiles = totalFiles;
            counter.textContent = formatCounterMessage();

            const stats = snapshot.stats || {};
            const graphStats = stats.callGraphStats || callGraph.stats || {};
            const totalEdges = graphStats.totalEdges ?? callGraph.edges.length;
            const staticEdges = graphStats.staticEdges ?? 0;
            const dynamicEdges = graphStats.dynamicEdges ?? 0;
            const resolvedEdges = graphStats.resolvedEdges ?? 0;
            const ambiguousEdges = graphStats.ambiguousEdges ?? 0;
            const unresolvedEdges = graphStats.unresolvedEdges ?? 0;

            const resolutionDetails = [];
            if (resolvedEdges) resolutionDetails.push(`${resolvedEdges} resolved`);
            if (ambiguousEdges) resolutionDetails.push(`${ambiguousEdges} ambiguous`);
            if (unresolvedEdges) resolutionDetails.push(`${unresolvedEdges} unresolved`);
            const resolutionSummary = resolutionDetails.length ? ` · ${resolutionDetails.join(' / ')}` : '';

            let embeddingSummary = '';
            if (embeddingMetadata && (embeddingMetadata.modelId || embeddingMetadata.dimension)) {
                const dim = embeddingMetadata.dimension ? `${embeddingMetadata.dimension}-dim` : 'unknown-dim';
                const backendLabel = embeddingMetadata.backend ? embeddingMetadata.backend.toUpperCase() : 'WASM';
                let reuseLabel = '';
                if (usedCachedEmbeddings) {
                    reuseLabel = ', cached';
                } else if ((embeddingReuseCounts.reused || 0) > 0 || (embeddingReuseCounts.embedded || 0) > 0) {
                    const reusedLabel = `${(embeddingReuseCounts.reused || 0).toLocaleString()} reused`;
                    const embeddedLabel = (embeddingReuseCounts.embedded || 0) > 0
                        ? ` / ${(embeddingReuseCounts.embedded || 0).toLocaleString()} new`
                        : '';
                    reuseLabel = `, ${reusedLabel}${embeddedLabel}`;
                }
                const chunkCount = snapshot.embedding?.chunkCount ?? null;
                const chunkLabel = Number.isFinite(chunkCount)
                    ? `${chunkCount.toLocaleString()} embedding chunk${chunkCount !== 1 ? 's' : ''}`
                    : 'embeddings cached';
                embeddingSummary = ` · ${chunkLabel} (${dim}, ${backendLabel}${reuseLabel})`;
            } else if (embeddingError) {
                embeddingSummary = ' · Embeddings failed previously';
            }

            let similaritySummary = '';
            if (similarityEdges.length > 0) {
                similaritySummary = ` · ${similarityEdges.length.toLocaleString()} similarity edge${similarityEdges.length !== 1 ? 's' : ''}`;
            }

            const functionCount = stats.functionCount ?? allFunctions.length;
            functionsCounter.textContent = `${functionCount.toLocaleString()} function${functionCount !== 1 ? 's' : ''} cached · ${totalEdges.toLocaleString()} call edge${totalEdges !== 1 ? 's' : ''} (${staticEdges.toLocaleString()} static · ${dynamicEdges.toLocaleString()} dynamic)${resolutionSummary}${embeddingSummary}${similaritySummary}`;

            displayResults();
            progressContainer.classList.add('hidden');
            resultsContainer.classList.remove('hidden');
            visualizeBtn.classList.remove('hidden');
            visualizeBtn.style.display = 'block';
            visualizeBtn.style.visibility = 'visible';
            visualizeBtn.style.opacity = '1';

            resumeSnapshot = snapshot;
            await initializeVisualization();
        }

        function createLayoutPersistenceProvider(layoutKey, layoutHash) {
            if (!storageReady || !storageClient) {
                return null;
            }
            return {
                async save({ key, snapshot, metadata }) {
                    await saveLayoutSnapshot(storageClient, {
                        graphKey: key,
                        graphHash: layoutHash,
                        snapshot,
                        metadata: {
                            ...(metadata || {}),
                            graphKey: key,
                            graphHash: layoutHash
                        }
                    });
                },
                async load({ key }) {
                    return loadLayoutSnapshot(storageClient, key);
                },
                async delete({ key }) {
                    await deleteLayoutSnapshot(storageClient, key);
                },
                async has({ key }) {
                    const response = await listLayoutSnapshots(storageClient, { graphKey: key, limit: 1 });
                    return Array.isArray(response?.snapshots) && response.snapshots.length > 0;
                }
            };
        }

        function describeLayoutStatus(loadInfo, restored) {
            const target = storageReady ? 'OPFS storage' : 'browser storage';
            if (restored) {
                return { message: `Layout restored from ${target}.`, tone: 'success', timeout: undefined };
            }
            switch (loadInfo?.status) {
                case 'mismatch':
                    return { message: 'Saved layout found but incompatible with current graph.', tone: 'error', timeout: 5000 };
                case 'error':
                    return { message: 'Unable to load saved layout.', tone: 'error', timeout: 5000 };
                case 'ok':
                case 'ok-local':
                    return { message: 'Saved layout found but could not be applied.', tone: 'error', timeout: 5000 };
                default:
                    return { message: 'Layout will auto-save when you choose “Save Layout”.', tone: 'info', timeout: 5000 };
            }
        }

        function extractLayoutHash(layoutKey = '') {
            if (typeof layoutKey !== 'string') {
                return null;
            }
            const parts = layoutKey.split(':');
            return parts.length ? parts[parts.length - 1] || null : null;
        }

        function computeLayoutStorageKey(graph) {
            const prefix = 'helios:v1:layout';
            if (!graph || !Array.isArray(graph.nodes)) {
                return `${prefix}:default`;
            }

            const nodeCount = graph.nodes.length;
            const edgeCount = Array.isArray(graph.edges) ? graph.edges.length : 0;
            const signatureSample = (graph.nodes || [])
                .slice(0, 64)
                .map(node => node.id || node.fqName || node.name || '')
                .sort()
                .join('|');

            const hash = hashString(`${nodeCount}:${edgeCount}:${signatureSample}`);
            return `${prefix}:${hash}`;
        }

        function hashString(value = '') {
            let hash = 0;
            for (let i = 0; i < value.length; i += 1) {
                hash = ((hash << 5) - hash) + value.charCodeAt(i);
                hash |= 0;
            }
            return Math.abs(hash).toString(16);
        }

        async function bootstrapApp() {
            try {
                await ensureStorageClient();
            } catch (err) {
                console.warn('Storage initialization failed:', err);
            }

            await initializeResumeOption();
        }

        bootstrapApp().catch(err => {
            console.error('HELIOS bootstrap error:', err);
            setStorageStatus('Initialization failed. See console for details.', 'error');
        });
    </script>
</body>
</html>
