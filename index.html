<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HELIOS - See the gravity of your code</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700;800&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <script type="importmap">
    {
        "imports": {
          "web-tree-sitter": "https://cdn.jsdelivr.net/npm/web-tree-sitter@0.20.4/dist/tree-sitter.esm.min.js",
          "3d-force-graph": "https://cdn.jsdelivr.net/npm/3d-force-graph@1.70.25/dist/3d-force-graph.es.min.js",
          "@xenova/transformers": "https://cdn.jsdelivr.net/npm/@xenova/transformers@2.8.0/dist/transformers.esm.min.js"
        }
    }
    </script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/themes/prism-tomorrow.min.css">
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-clike.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-javascript.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-typescript.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-jsx.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-tsx.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-python.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: linear-gradient(135deg, #0a0e27 0%, #1a1a3e 25%, #2d1b4e 50%, #1a1a3e 75%, #0a0e27 100%);
            background-size: 400% 400%;
            animation: gradientShift 15s ease infinite;
            min-height: 100vh;
            overflow: hidden;
            position: relative;
        }

        @keyframes gradientShift {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }

        .stars,
        .gravity-particles {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        .stars {
            z-index: 1;
        }

        .gravity-particles {
            z-index: 2;
        }

        .star {
            position: absolute;
            width: 2px;
            height: 2px;
            background: white;
            border-radius: 50%;
            opacity: 0.6;
            animation: twinkle 3s ease-in-out infinite;
        }

        .star:nth-child(odd) { animation-duration: 2s; }
        .star:nth-child(3n) { animation-duration: 4s; opacity: 0.4; }

        @keyframes twinkle {
            0%, 100% { opacity: 0.3; transform: scale(1); }
            50% { opacity: 0.9; transform: scale(1.2); }
        }

        .gravity-particle {
            position: absolute;
            width: 1px;
            height: 1px;
            background: rgba(199, 210, 254, 0.3);
            border-radius: 50%;
            animation: orbit 20s linear infinite;
        }

        .gravity-particle:nth-child(1) { top: 20%; left: 10%; animation-duration: 25s; }
        .gravity-particle:nth-child(2) { top: 60%; left: 80%; animation-duration: 30s; animation-delay: -5s; }
        .gravity-particle:nth-child(3) { top: 80%; left: 20%; animation-duration: 35s; animation-delay: -10s; }

        @keyframes orbit {
            0% { transform: rotate(0deg) translateX(100px) rotate(0deg); }
            100% { transform: rotate(360deg) translateX(100px) rotate(-360deg); }
        }

        @keyframes fadeInUp {
            from { opacity: 0; transform: translateY(30px); }
            to { opacity: 1; transform: translateY(0); }
        }

        @keyframes float {
            0%, 100% { transform: translateY(0px); }
            50% { transform: translateY(-20px); }
        }

        .hero-container {
            position: relative;
            z-index: 5;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 4rem 1.5rem;
        }

        .title {
            font-weight: 800;
            font-size: clamp(3.5rem, 10vw, 6rem);
            letter-spacing: -0.02em;
            background: linear-gradient(135deg, #ffffff 0%, #e0e7ff 50%, #c7d2fe 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-shadow: 0 0 40px rgba(199, 210, 254, 0.3),
                         0 0 80px rgba(199, 210, 254, 0.2),
                         0 0 120px rgba(199, 210, 254, 0.1);
            animation: fadeInUp 1s ease-out, float 6s ease-in-out infinite;
            margin-bottom: 1rem;
        }

        .tagline {
            font-weight: 300;
            font-size: clamp(1.125rem, 2.5vw, 1.5rem);
            color: #a5b4fc;
            letter-spacing: 0.05em;
            opacity: 0;
            animation: fadeInUp 1s ease-out 0.4s forwards;
            margin-bottom: 3rem;
        }

        .button {
            position: relative;
            padding: 1rem 2.5rem;
            font-size: 1.125rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%);
            border: none;
            border-radius: 0.75rem;
            cursor: pointer;
            overflow: hidden;
            transition: all 0.3s ease;
            box-shadow: 0 10px 30px rgba(99, 102, 241, 0.3), 0 0 20px rgba(139, 92, 246, 0.2);
            opacity: 0;
            animation: fadeInUp 1s ease-out 0.6s forwards;
        }

        .button::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: left 0.5s;
        }

        .button:hover::before { left: 100%; }
        .button:hover { transform: translateY(-2px) scale(1.05); box-shadow: 0 15px 40px rgba(99, 102, 241, 0.4), 0 0 30px rgba(139, 92, 246, 0.3); }
        .button:active { transform: translateY(0) scale(1.02); }

        .results-container,
        .progress-container {
            max-width: 960px;
            width: 100%;
            margin: 2.5rem auto 0;
            padding: 2rem;
            background: rgba(15, 23, 42, 0.65);
            backdrop-filter: blur(12px);
            border-radius: 1rem;
            border: 1px solid rgba(199, 210, 254, 0.12);
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.35);
            animation: fadeInUp 0.6s ease-out;
        }

        .counter {
            font-size: 1.25rem;
            color: #a5b4fc;
            margin-bottom: 1.25rem;
            font-weight: 600;
        }

        .progress-text {
            color: #a5b4fc;
            font-size: 1rem;
            text-align: center;
            margin-bottom: 1rem;
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: rgba(30, 41, 59, 0.5);
            border-radius: 4px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, #6366f1 0%, #8b5cf6 100%);
            transition: width 0.3s ease;
            border-radius: 4px;
            box-shadow: 0 0 10px rgba(99, 102, 241, 0.5);
        }

        .file-list {
            max-height: 420px;
            overflow-y: auto;
            padding-right: 0.5rem;
        }

        .file-list::-webkit-scrollbar { width: 8px; }
        .file-list::-webkit-scrollbar-track { background: rgba(15, 23, 42, 0.5); border-radius: 4px; }
        .file-list::-webkit-scrollbar-thumb { background: rgba(199, 210, 254, 0.35); border-radius: 4px; }
        .file-list::-webkit-scrollbar-thumb:hover { background: rgba(199, 210, 254, 0.55); }

        .file-item {
            padding: 0.75rem 1rem;
            margin-bottom: 0.5rem;
            background: rgba(30, 41, 59, 0.55);
            border-radius: 0.5rem;
            border-left: 3px solid #6366f1;
            color: #e0e7ff;
            font-family: 'Monaco', 'Menlo', 'Courier New', monospace;
            font-size: 0.9rem;
            word-break: break-all;
            transition: all 0.2s ease;
        }

        .file-item:hover { background: rgba(30, 41, 59, 0.8); border-left-color: #8b5cf6; transform: translateX(4px); }

        .hidden { display: none !important; }

        .viz-container {
            position: fixed;
            inset: 0;
            display: grid;
            grid-template-columns: 1fr 360px;
            background: rgba(10, 14, 39, 0.97);
            z-index: 50;
        }

        .viz-graph {
            position: relative;
            width: 100%;
            height: 100%;
        }

        .viz-sidebar {
            display: flex;
            flex-direction: column;
            background: rgba(15, 23, 42, 0.95);
            border-left: 1px solid rgba(199, 210, 254, 0.12);
            overflow: hidden;
        }

        .viz-controls,
        .viz-inspector {
            padding: 1.5rem;
            overflow-y: auto;
        }

        .viz-controls {
            border-bottom: 1px solid rgba(199, 210, 254, 0.1);
        }

        .inspector-panel {
            display: none;
        }

        .inspector-panel.visible {
            display: block;
        }

        .inspector-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
            padding-bottom: 0.75rem;
            border-bottom: 1px solid rgba(199, 210, 254, 0.1);
        }

        .inspector-title {
            font-size: 1.125rem;
            font-weight: 600;
            color: #e0e7ff;
        }

        .inspector-close {
            background: none;
            border: none;
            color: #a5b4fc;
            font-size: 1.5rem;
            cursor: pointer;
            padding: 0.25rem 0.5rem;
        }

        .inspector-content {
            color: #e0e7ff;
        }

        .inspector-info {
            margin-bottom: 1.5rem;
        }

        .inspector-edges {
            margin-bottom: 1.25rem;
            display: grid;
            gap: 1rem;
        }

        .inspector-edges-section {
            background: rgba(30, 41, 59, 0.4);
            border: 1px solid rgba(148, 163, 184, 0.2);
            border-radius: 0.5rem;
            padding: 0.75rem;
        }

        .inspector-edges-title {
            font-size: 0.85rem;
            font-weight: 600;
            color: #c7d2fe;
            margin-bottom: 0.5rem;
        }

        .inspector-edge-list {
            display: flex;
            flex-direction: column;
            gap: 0.4rem;
        }

        .inspector-edge-btn {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            background: rgba(79, 70, 229, 0.2);
            border: 1px solid rgba(99, 102, 241, 0.35);
            border-radius: 0.5rem;
            padding: 0.45rem 0.6rem;
            color: #e0e7ff;
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .inspector-edge-btn:hover {
            background: rgba(99, 102, 241, 0.3);
            border-color: rgba(129, 140, 248, 0.6);
        }

        .inspector-edge-label {
            font-weight: 600;
            margin-bottom: 0.1rem;
        }

        .inspector-edge-meta {
            font-size: 0.7rem;
            color: #cbd5f5;
            margin-bottom: 0.1rem;
        }

        .inspector-edge-path {
            font-size: 0.68rem;
            color: #94a3b8;
            word-break: break-all;
        }

        .inspector-edge-empty,
        .inspector-edge-more {
            font-size: 0.75rem;
            color: #a5b4fc;
        }

        .info-row {
            margin-bottom: 0.75rem;
            font-size: 0.9rem;
            line-height: 1.6;
        }

        .info-row strong { color: #a5b4fc; margin-right: 0.4rem; }

        .info-row code {
            background: rgba(30, 41, 59, 0.6);
            padding: 0.15rem 0.4rem;
            border-radius: 0.25rem;
            font-size: 0.85em;
            color: #c7d2fe;
        }

        .inspector-code-container {
            margin-top: 1rem;
        }

        .inspector-code {
            max-height: 320px;
            overflow-y: auto;
            background: rgba(9, 13, 33, 0.85);
            border: 1px solid rgba(99, 102, 241, 0.25);
            border-radius: 0.5rem;
            padding: 1rem;
            color: #e0e7ff;
            font-size: 0.85rem;
        }

        .controls-section {
            margin-bottom: 1.5rem;
        }

        .controls-title {
            font-size: 1rem;
            font-weight: 600;
            color: #a5b4fc;
            margin-bottom: 0.75rem;
        }

        .control-toggle {
            display: flex;
            align-items: center;
            margin-bottom: 0.5rem;
            color: #e0e7ff;
            font-size: 0.9rem;
        }

        .control-toggle input { margin-right: 0.5rem; cursor: pointer; }

        .control-button {
            width: 100%;
            padding: 0.5rem 1rem;
            margin-bottom: 0.6rem;
            background: rgba(99, 102, 241, 0.25);
            border: 1px solid rgba(99, 102, 241, 0.3);
            border-radius: 0.5rem;
            color: #e0e7ff;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .control-button:hover { background: rgba(99, 102, 241, 0.35); border-color: rgba(99, 102, 241, 0.5); }

        .control-filter {
            margin-bottom: 0.85rem;
        }

        .control-filter label {
            display: block;
            color: #a5b4fc;
            font-size: 0.85rem;
            margin-bottom: 0.35rem;
        }

        .control-filter input,
        .control-filter select {
            width: 100%;
            padding: 0.5rem;
            background: rgba(30, 41, 59, 0.55);
            border: 1px solid rgba(199, 210, 254, 0.18);
            border-radius: 0.4rem;
            color: #e0e7ff;
            font-size: 0.9rem;
        }

        .hover-info-primary {
            margin-bottom: 0.75rem;
        }

        .hover-info-name {
            font-weight: 600;
            color: #e0e7ff;
            font-size: 0.95rem;
            margin-bottom: 0.25rem;
        }

        .hover-info-path {
            font-size: 0.75rem;
            color: #94a3b8;
            word-break: break-all;
        }

        .hover-info-metrics {
            display: flex;
            flex-wrap: wrap;
            gap: 0.4rem;
            margin-bottom: 0.65rem;
        }

        .hover-info-badge {
            background: rgba(148, 163, 184, 0.2);
            color: #e2e8f0;
            padding: 0.25rem 0.5rem;
            border-radius: 9999px;
            font-size: 0.72rem;
            letter-spacing: 0.01em;
        }

        .hover-info-neighbors {
            display: flex;
            flex-wrap: wrap;
            gap: 0.35rem;
        }

        .hover-neighbor-btn {
            background: rgba(79, 70, 229, 0.2);
            border: 1px solid rgba(99, 102, 241, 0.4);
            color: #c7d2fe;
            border-radius: 9999px;
            padding: 0.25rem 0.65rem;
            font-size: 0.72rem;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .hover-neighbor-btn:hover {
            background: rgba(99, 102, 241, 0.35);
            border-color: rgba(99, 102, 241, 0.6);
        }

        .hover-neighbor-empty,
        .hover-neighbor-more {
            font-size: 0.75rem;
            color: #a5b4fc;
        }

        .viz-close-button {
            position: absolute;
            top: 1.5rem;
            right: 1.5rem;
            z-index: 60;
            padding: 0.75rem 1.5rem;
            background: rgba(15, 23, 42, 0.9);
            color: #e0e7ff;
            border: 1px solid rgba(199, 210, 254, 0.25);
            border-radius: 0.5rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .viz-close-button:hover { background: rgba(15, 23, 42, 1); border-color: rgba(199, 210, 254, 0.4); }

        @media (max-width: 1024px) {
            .viz-container {
                grid-template-columns: 1fr;
            }

            .viz-sidebar {
                position: absolute;
                right: 0;
                top: 0;
                bottom: 0;
                width: min(360px, 90vw);
                box-shadow: -12px 0 40px rgba(0, 0, 0, 0.5);
            }
        }
    </style>
</head>
<body>
    <div class="stars" id="stars"></div>
    <div class="gravity-particles">
        <div class="gravity-particle"></div>
        <div class="gravity-particle"></div>
        <div class="gravity-particle"></div>
    </div>

    <div class="hero-container">
        <div class="text-center space-y-6">
            <h1 class="title">HELIOS</h1>
            <p class="tagline">See the gravity of your code</p>
            <div style="display: flex; gap: 1rem; justify-content: center; flex-wrap: wrap;">
                <button class="button" id="selectBtn">Select Repository</button>
                <button class="button hidden" id="resumeBtn" style="background: rgba(129, 140, 248, 0.15); border: 1px solid rgba(129, 140, 248, 0.5);">
                    Resume Last Session
                </button>
            </div>
        </div>

        <div class="progress-container hidden" id="progressContainer">
            <div class="progress-text" id="progressText">Scanning files...</div>
            <div class="progress-bar">
                <div class="progress-fill" id="progressFill"></div>
            </div>
        </div>

        <div class="results-container hidden" id="resultsContainer">
            <div class="counter" id="counter">Found 0 JavaScript files</div>
            <div class="counter" id="functionsCounter" style="font-size: 1rem; opacity: 0.85;">0 functions extracted</div>
            <div class="file-list" id="fileList"></div>
            <button class="button hidden" id="visualizeBtn" style="margin-top: 2rem;">Visualize Graph</button>
        </div>
    </div>

    <div class="viz-container hidden" id="vizContainer">
        <div class="viz-graph" id="vizGraph"></div>
        <div class="viz-sidebar">
            <div class="viz-controls" id="vizControls"></div>
            <div class="viz-inspector" id="vizInspector"></div>
        </div>
        <button class="viz-close-button" id="vizCloseBtn">Close Visualization</button>
    </div>

    <script type="module">
        import { parserManager } from './src/parser/parser.js';
        import { extractJavaScript } from './src/extractors/javascript.js';
        import { SymbolTableManager } from './src/extractors/symbol-table.js';
        import { extractPython } from './src/extractors/python.js';
        import { buildCallGraph } from './src/extractors/call-graph.js';
        import { GraphVisualization } from './src/viz/graph-viz.js';
        import { InspectorPanel } from './src/viz/inspector.js';
        import { VisualizationControls } from './src/viz/controls.js';
        import { EmbeddingManager } from './src/embeddings/embedding-manager.js';
        import { buildFunctionEmbeddings, computeSimilarityGraph } from './src/embeddings/similarity.js';
        import {
            computeFunctionFingerprint,
            computeFunctionFingerprintMap,
            loadEmbeddingsForFunctions,
            loadFunctionFingerprintMap,
            persistEmbeddingRun,
            tryLoadEmbeddingRun
        } from './src/embeddings/persistence.js';
        import { StorageWorkerClient } from './src/storage/client.js';
        import {
            saveLayoutSnapshot,
            loadLayoutSnapshot,
            deleteLayoutSnapshot,
            listLayoutSnapshots
        } from './src/storage/layout-persistence.js';
        import {
            saveAnalysisSnapshot,
            loadAnalysisSnapshot
        } from './src/storage/resume-flow.js';

        const starsContainer = document.getElementById('stars');
        const starCount = 120;
        for (let i = 0; i < starCount; i++) {
            const star = document.createElement('div');
            star.className = 'star';
            star.style.left = Math.random() * 100 + '%';
            star.style.top = Math.random() * 100 + '%';
            star.style.animationDelay = Math.random() * 3 + 's';
            starsContainer.appendChild(star);
        }

        const selectBtn = document.getElementById('selectBtn');
        const resumeBtn = document.getElementById('resumeBtn');
        const progressContainer = document.getElementById('progressContainer');
        const progressText = document.getElementById('progressText');
        const progressFill = document.getElementById('progressFill');
        const resultsContainer = document.getElementById('resultsContainer');
        const counter = document.getElementById('counter');
        const functionsCounter = document.getElementById('functionsCounter');
        const fileList = document.getElementById('fileList');
        const visualizeBtn = document.getElementById('visualizeBtn');
        const vizContainer = document.getElementById('vizContainer');
        const vizGraph = document.getElementById('vizGraph');
        const vizControls = document.getElementById('vizControls');
        const vizInspector = document.getElementById('vizInspector');
        const vizCloseBtn = document.getElementById('vizCloseBtn');

        const SUPPORTED_EXTENSIONS = ['.js', '.jsx', '.ts', '.tsx', '.py'];
        const JS_FILE_EXTENSIONS = ['.js', '.jsx', '.ts', '.tsx', '.mjs', '.cjs'];
        const JS_INDEX_FILENAMES = ['index.js', 'index.jsx', 'index.ts', 'index.tsx'];
        const PY_FILE_EXTENSIONS = ['.py'];
        const PY_PACKAGE_FILENAMES = ['__init__.py'];
        const languageDisplayNames = {
            javascript: 'JavaScript',
            typescript: 'TypeScript',
            python: 'Python'
        };

        let sourceFiles = [];
        let fileHandles = new Map();
        const sourceFileIndex = new Map();
        const moduleIndex = new Map();
        let totalFiles = 0;
        let scannedFiles = 0;
        let allFunctions = [];
        let allCalls = [];
        let callGraph = null;

        let graphViz = null;
        let inspector = null;
        let controls = null;
        let fullVizData = null;
        let functionMapById = new Map();
        let embeddingManager = null;
        let embeddingChunks = [];
        let embeddingStats = null;
        let embeddingVectors = [];
        let embeddingMetadata = {
            backend: null,
            modelId: null,
            dimension: null
        };
        let embeddingError = null;
        let embeddingFingerprint = null;
        let usedCachedEmbeddings = false;
        let embeddingReuseCounts = { reused: 0, embedded: 0 };
        let functionEmbeddings = [];
        let similarityEdges = [];
        let similarityStats = null;
        const similarityConfig = {
            maxNeighbors: 8,
            candidateLimit: 20,
            bundleTopK: 3,
            similarityThreshold: 0.65
        };

        let storageClient = null;
        let storageReady = false;
        let storageClientInitPromise = null;
        let latestEmbeddingSummary = null;
        let latestFunctionFingerprintMap = null;
        let resumeSnapshot = null;

        const symbolTableManager = new SymbolTableManager();
        function updateEmbeddingSummary(summary) {
            latestEmbeddingSummary = summary;
            if (controls && typeof controls.setEmbeddingSummary === 'function') {
                controls.setEmbeddingSummary(summary);
            }
        }

        try {
            embeddingManager = new EmbeddingManager();
            window.heliosEmbeddingManager = embeddingManager;
        } catch (err) {
            console.warn('Embeddings unavailable in this environment:', err);
            embeddingManager = null;
            window.heliosEmbeddingManager = null;
        }

        if (!window.showDirectoryPicker) {
            selectBtn.textContent = 'File System Access API not supported';
            selectBtn.disabled = true;
            selectBtn.style.opacity = '0.5';
            selectBtn.style.cursor = 'not-allowed';
        }

        resumeBtn?.addEventListener('click', async () => {
            if (!resumeSnapshot) {
                return;
            }
            resumeBtn.classList.add('hidden');
            try {
                await hydrateFromSnapshot(resumeSnapshot);
            } catch (err) {
                console.error('Failed to resume previous session:', err);
                resumeBtn.classList.remove('hidden');
            }
        });

        selectBtn.addEventListener('click', async () => {
            try {
                const directoryHandle = await window.showDirectoryPicker();

                sourceFiles = [];
                fileHandles.clear();
                sourceFileIndex.clear();
                moduleIndex.clear();
                allFunctions = [];
                allCalls = [];
                callGraph = null;
                fullVizData = null;
                functionMapById = new Map();
                embeddingChunks = [];
                embeddingStats = null;
                embeddingVectors = [];
                embeddingMetadata = {
                    backend: null,
                    modelId: null,
                    dimension: null
                };
                embeddingError = null;
                embeddingReuseCounts = { reused: 0, embedded: 0 };
                latestFunctionFingerprintMap = null;
                resumeSnapshot = null;
                resumeBtn?.classList.add('hidden');
                window.heliosEmbeddingChunks = [];
                window.heliosEmbeddingStats = null;
                window.heliosEmbeddings = null;
                window.heliosEmbeddingReuse = null;
                window.heliosEmbeddingError = null;
                updateEmbeddingSummary(null);
                functionEmbeddings = [];
                similarityEdges = [];
                similarityStats = null;
                window.heliosFunctionEmbeddings = null;
                window.heliosSimilarity = null;
                scannedFiles = 0;
                totalFiles = 0;
                fileList.innerHTML = '';
                functionsCounter.textContent = '0 functions extracted';
                visualizeBtn.classList.add('hidden');
                progressFill.style.width = '0%';
                progressText.textContent = 'Initializing parser...';
                resultsContainer.classList.add('hidden');
                progressContainer.classList.remove('hidden');

                await parserManager.initialize();
                await ensureStorageClient();

                progressText.textContent = 'Counting files...';
                totalFiles = await countFiles(directoryHandle);
                progressText.textContent = 'Scanning files...';
                await scanDirectory(directoryHandle, '');

                progressText.textContent = 'Parsing source files...';
                await parseSourceFiles();

                progressText.textContent = 'Building call graph...';
                callGraph = buildCallGraph(allFunctions, allCalls, symbolTableManager);

                const stats = callGraph?.stats || { totalEdges: 0, staticEdges: 0, dynamicEdges: 0 };

                if (embeddingManager) {
                    try {
                        embeddingFingerprint = await computeFunctionFingerprint(allFunctions);
                    } catch (err) {
                        console.warn('Failed to compute embedding fingerprint:', err);
                        embeddingFingerprint = null;
                    }

                    try {
                        const prepared = embeddingManager.prepareFunctionChunks(allFunctions);
                        embeddingChunks = prepared.chunks;
                        embeddingStats = prepared.stats;
                        window.heliosEmbeddingChunks = embeddingChunks;
                        window.heliosEmbeddingStats = embeddingStats;

                        usedCachedEmbeddings = false;
                        let persistedEmbeddingData = null;

                        if (embeddingChunks.length > 0 && embeddingFingerprint) {
                            try {
                                progressText.textContent = 'Checking cached embeddings...';
                                persistedEmbeddingData = await tryLoadEmbeddingRun({
                                    functions: allFunctions,
                                    chunks: embeddingChunks,
                                    fingerprint: embeddingFingerprint
                                });
                            } catch (err) {
                                console.warn('Failed to load persisted embeddings:', err);
                            }
                        }

                        if (persistedEmbeddingData) {
                            usedCachedEmbeddings = true;
                            embeddingVectors = persistedEmbeddingData.embeddings || [];
                            embeddingMetadata = {
                                backend: persistedEmbeddingData.metadata?.backend || null,
                                modelId: persistedEmbeddingData.metadata?.modelId || null,
                                dimension: persistedEmbeddingData.metadata?.dimension || null,
                                quantized: persistedEmbeddingData.metadata?.quantized || false
                            };
                            latestFunctionFingerprintMap = persistedEmbeddingData.functionFingerprints || null;
                            embeddingReuseCounts = {
                                reused: embeddingChunks.length,
                                embedded: 0
                            };
                            similarityEdges = persistedEmbeddingData.similarityEdges || [];
                            window.heliosEmbeddings = {
                                chunks: embeddingChunks,
                                embeddings: embeddingVectors,
                                metadata: embeddingMetadata,
                                stats: embeddingStats,
                                cached: true,
                                reuse: embeddingReuseCounts
                            };
                            window.heliosEmbeddingError = null;
                            window.heliosEmbeddingReuse = embeddingReuseCounts;
                        } else if (embeddingChunks.length > 0) {
                            const functionFingerprintMap = computeFunctionFingerprintMap(allFunctions);
                            latestFunctionFingerprintMap = functionFingerprintMap;

                            let storedFunctionFingerprints = {};
                            try {
                                storedFunctionFingerprints = await loadFunctionFingerprintMap();
                            } catch (err) {
                                console.warn('Failed to load stored function fingerprints:', err);
                            }

                            const unchangedFunctionIds = [];
                            const changedFunctionIds = [];
                            allFunctions.forEach(fn => {
                                const currentFingerprint = functionFingerprintMap[fn.id];
                                const storedFingerprint = storedFunctionFingerprints?.[fn.id];
                                if (storedFingerprint && currentFingerprint === storedFingerprint) {
                                    unchangedFunctionIds.push(fn.id);
                                } else {
                                    changedFunctionIds.push(fn.id);
                                }
                            });

                            let reuseEmbeddings = [];
                            let reuseMetadata = null;
                            let reuseMissingFunctions = [];

                            if (unchangedFunctionIds.length > 0) {
                                progressText.textContent = `Reusing cached embeddings (${unchangedFunctionIds.length.toLocaleString()} function${unchangedFunctionIds.length !== 1 ? 's' : ''})...`;
                                try {
                                    const reuseResult = await loadEmbeddingsForFunctions({
                                        functions: allFunctions,
                                        chunks: embeddingChunks,
                                        targetFunctionIds: unchangedFunctionIds
                                    });
                                    reuseEmbeddings = reuseResult.embeddings || [];
                                    reuseMetadata = reuseResult.metadata || null;
                                    reuseMissingFunctions = reuseResult.missingFunctions || [];
                                } catch (err) {
                                    console.warn('Failed to reuse cached embeddings:', err);
                                }
                            }

                            const changedIdSet = new Set([
                                ...changedFunctionIds,
                                ...reuseMissingFunctions
                            ]);

                            const functionsToEmbed = allFunctions.filter(fn => changedIdSet.has(fn.id));
                            const chunksToEmbed = embeddingChunks.filter(chunk => changedIdSet.has(chunk.functionId));

                            let embeddingResult = {
                                chunks: chunksToEmbed,
                                embeddings: [],
                                backend: null,
                                modelId: null,
                                dimension: null,
                                stats: null
                            };

                            if (functionsToEmbed.length > 0) {
                                progressText.textContent = `Initializing embedding model (${chunksToEmbed.length.toLocaleString()} chunk${chunksToEmbed.length !== 1 ? 's' : ''})...`;
                                const initInfo = await embeddingManager.initialize();
                                embeddingMetadata = {
                                    backend: initInfo.backend || embeddingMetadata.backend,
                                    modelId: initInfo.modelId || embeddingMetadata.modelId,
                                    dimension: initInfo.dimension || embeddingMetadata.dimension
                                };

                                const totalTokens = chunksToEmbed.reduce(
                                    (sum, chunk) => sum + (chunk.tokenCount ?? 0),
                                    0
                                );
                                const preparedSubset = {
                                    chunks: chunksToEmbed,
                                    stats: {
                                        processedFunctions: functionsToEmbed.length,
                                        chunkCount: chunksToEmbed.length,
                                        totalTokens,
                                        averageTokens: chunksToEmbed.length ? totalTokens / chunksToEmbed.length : 0,
                                        averageChunksPerFunction: functionsToEmbed.length ? chunksToEmbed.length / functionsToEmbed.length : 0
                                    }
                                };

                                progressText.textContent = `Generating embeddings (${chunksToEmbed.length.toLocaleString()} chunk${chunksToEmbed.length !== 1 ? 's' : ''})...`;
                                embeddingResult = await embeddingManager.embedFunctions(functionsToEmbed, {
                                    preparedChunks: preparedSubset
                                });
                            } else if (reuseMetadata) {
                                embeddingMetadata = {
                                    backend: reuseMetadata.backend ?? embeddingMetadata.backend,
                                    modelId: reuseMetadata.modelId ?? embeddingMetadata.modelId,
                                    dimension: reuseMetadata.dimension ?? embeddingMetadata.dimension
                                };
                            }

                            embeddingVectors = [
                                ...(reuseEmbeddings || []),
                                ...(embeddingResult.embeddings || [])
                            ];

                            embeddingMetadata = {
                                backend: embeddingResult.backend || embeddingMetadata.backend || reuseMetadata?.backend || null,
                                modelId: embeddingResult.modelId || embeddingMetadata.modelId || reuseMetadata?.modelId || null,
                                dimension: embeddingResult.dimension || embeddingMetadata.dimension || reuseMetadata?.dimension || null
                            };

                            embeddingReuseCounts = {
                                reused: reuseEmbeddings.length,
                                embedded: embeddingResult.embeddings?.length || 0
                            };

                            window.heliosEmbeddings = {
                                chunks: embeddingChunks,
                                embeddings: embeddingVectors,
                                metadata: embeddingMetadata,
                                stats: embeddingStats,
                                reuse: embeddingReuseCounts,
                                partial: true
                            };
                            window.heliosEmbeddingError = null;
                            window.heliosEmbeddingReuse = embeddingReuseCounts;
                        } else {
                            embeddingMetadata = {
                                backend: null,
                                modelId: embeddingManager?.modelId || null,
                                dimension: null
                            };
                            window.heliosEmbeddings = {
                                chunks: [],
                                embeddings: [],
                                metadata: embeddingMetadata,
                                stats: embeddingStats,
                                reuse: embeddingReuseCounts
                            };
                            window.heliosEmbeddingError = null;
                            window.heliosEmbeddingReuse = embeddingReuseCounts;
                        }
                    } catch (err) {
                        embeddingError = err;
                        window.heliosEmbeddingError = err;
                        console.error('Embedding pipeline failed:', err);
                    }
                }

                if (embeddingVectors.length > 0 && embeddingMetadata.dimension) {
                    functionEmbeddings = buildFunctionEmbeddings({
                        functions: allFunctions,
                        embeddings: embeddingVectors,
                        dimension: embeddingMetadata.dimension
                    });
                    if (!usedCachedEmbeddings) {
                        const similarityResult = computeSimilarityGraph(functionEmbeddings, similarityConfig);
                        similarityEdges = similarityResult.edges || [];
                        similarityStats = similarityResult.stats || null;
                        window.heliosSimilarity = similarityResult;
                    } else {
                        similarityStats = {
                            functionsWithEmbeddings: functionEmbeddings.length,
                            finalEdges: similarityEdges.length,
                            cached: true
                        };
                        window.heliosSimilarity = {
                            edges: similarityEdges,
                            stats: similarityStats
                        };
                    }
                    window.heliosFunctionEmbeddings = functionEmbeddings;
                } else {
                    functionEmbeddings = [];
                    similarityEdges = [];
                    similarityStats = null;
                    window.heliosFunctionEmbeddings = null;
                    window.heliosSimilarity = null;
                }

                updateEmbeddingSummary({
                    chunkCount: embeddingChunks.length,
                    metadata: embeddingMetadata,
                    reuse: embeddingReuseCounts,
                    cached: usedCachedEmbeddings,
                    similarityEdges: Array.isArray(similarityEdges) ? similarityEdges.length : null,
                    functionsWithEmbeddings: Array.isArray(functionEmbeddings) ? functionEmbeddings.length : null,
                    error: embeddingError
                });

                progressContainer.classList.add('hidden');
                resultsContainer.classList.remove('hidden');

                counter.textContent = formatCounterMessage();
                const resolutionDetails = [];
                if (typeof stats.resolvedEdges === 'number') {
                    resolutionDetails.push(`${stats.resolvedEdges} resolved`);
                }
                if (typeof stats.ambiguousEdges === 'number' && stats.ambiguousEdges > 0) {
                    resolutionDetails.push(`${stats.ambiguousEdges} ambiguous`);
                }
                if (typeof stats.unresolvedEdges === 'number' && stats.unresolvedEdges > 0) {
                    resolutionDetails.push(`${stats.unresolvedEdges} unresolved`);
                }
                const resolutionSummary = resolutionDetails.length ? ` · ${resolutionDetails.join(' / ')}` : '';

                let embeddingSummary = '';
                if (embeddingManager && embeddingError) {
                    embeddingSummary = ' · Embeddings failed';
                } else if (embeddingChunks.length > 0) {
                    const dim = embeddingMetadata.dimension ? `${embeddingMetadata.dimension}-dim` : 'unknown-dim';
                    const backendLabel = embeddingMetadata.backend ? embeddingMetadata.backend.toUpperCase() : 'WASM';
                    let reuseLabel = '';
                    if (usedCachedEmbeddings) {
                        reuseLabel = ', cached';
                    } else if (embeddingReuseCounts.reused > 0) {
                        const reusedLabel = `${embeddingReuseCounts.reused.toLocaleString()} reused`;
                        const embeddedLabel = embeddingReuseCounts.embedded > 0
                            ? ` / ${embeddingReuseCounts.embedded.toLocaleString()} new`
                            : '';
                        reuseLabel = `, ${reusedLabel}${embeddedLabel}`;
                    }
                    embeddingSummary = ` · ${embeddingChunks.length.toLocaleString()} embedding chunk${embeddingChunks.length !== 1 ? 's' : ''} (${dim}, ${backendLabel}${reuseLabel})`;
                }

                let similaritySummary = '';
                if (similarityEdges.length > 0) {
                    similaritySummary = ` · ${similarityEdges.length.toLocaleString()} similarity edge${similarityEdges.length !== 1 ? 's' : ''}`;
                }

                functionsCounter.textContent = `${allFunctions.length} function${allFunctions.length !== 1 ? 's' : ''} extracted · ${stats.totalEdges} call edge${stats.totalEdges !== 1 ? 's' : ''} (${stats.staticEdges} static · ${stats.dynamicEdges} dynamic)${resolutionSummary}${embeddingSummary}${similaritySummary}`;

                if (!usedCachedEmbeddings && embeddingVectors.length > 0) {
                    try {
                        progressText.textContent = 'Persisting embeddings...';
                        await persistEmbeddingRun({
                            functions: allFunctions,
                            chunks: embeddingChunks,
                            embeddings: embeddingVectors,
                            similarityEdges,
                            metadata: {
                                backend: embeddingMetadata.backend,
                                modelId: embeddingMetadata.modelId,
                                dimension: embeddingMetadata.dimension,
                                quantized: embeddingManager?.quantized ?? true
                            },
                            fingerprint: embeddingFingerprint || ''
                        }, {
                            functionFingerprints: latestFunctionFingerprintMap
                        });
                    } catch (err) {
                        console.warn('Failed to persist embedding results:', err);
                    }
                }

                displayResults();

                if (storageReady && storageClient && callGraph?.nodes?.length) {
                    try {
                        const snapshotLayoutKey = computeLayoutStorageKey(callGraph);
                        const savedSnapshot = await saveAnalysisSnapshot(storageClient, {
                            projectLabel: directoryHandle?.name || null,
                            sourceFiles,
                            callGraph,
                            similarityEdges,
                            embedding: {
                                metadata: embeddingMetadata,
                                reuse: embeddingReuseCounts,
                                stats: embeddingStats,
                                chunkCount: embeddingChunks.length,
                                cached: usedCachedEmbeddings,
                                error: embeddingError
                            },
                            embeddingFingerprint,
                            functionFingerprintMap: latestFunctionFingerprintMap,
                            layoutKey: snapshotLayoutKey
                        });
                        resumeSnapshot = savedSnapshot;
                        resumeBtn?.classList.remove('hidden');
                    } catch (err) {
                        console.warn('Failed to save analysis snapshot:', err);
                    }
                }

                if (allFunctions.length > 0 && stats.totalEdges >= 0) {
                    visualizeBtn.classList.remove('hidden');
                }

                window.heliosFunctions = allFunctions;
                window.heliosCalls = allCalls;
                window.heliosCallGraph = callGraph;
                window.heliosSymbolTables = symbolTableManager;

            } catch (error) {
                if (error?.name !== 'AbortError') {
                    console.error('Error selecting directory:', error);
                    progressText.textContent = 'Error: ' + (error?.message || 'Unknown error');
                    setTimeout(() => progressContainer.classList.add('hidden'), 3000);
                }
            }
        });

        visualizeBtn.addEventListener('click', async () => {
            if (!callGraph || !callGraph.nodes?.length) {
                alert('No call graph data available yet.');
                return;
            }
            await initializeVisualization();
        });

        vizCloseBtn.addEventListener('click', () => {
            vizContainer.classList.add('hidden');
            if (inspector) inspector.hide();
        });

        async function scanDirectory(directoryHandle, currentPath) {
            for await (const entry of directoryHandle.values()) {
                if (entry.kind === 'file') {
                    scannedFiles++;
                    const fileName = entry.name;
                    const fullPath = currentPath ? `${currentPath}/${fileName}` : fileName;

                    const extension = getExtension(fileName);
                    if (SUPPORTED_EXTENSIONS.includes(extension)) {
                        const language = parserManager.detectLanguage(fullPath);
                        if (language) {
                            const { moduleId, aliases } = createModuleMetadata(fullPath, language);
                            const fileMeta = { path: fullPath, language, moduleId, moduleAliases: aliases };
                            sourceFiles.push(fileMeta);
                            fileHandles.set(fullPath, entry);
                            registerSourceFile(fileMeta);
                        }
                    }

                    updateProgress('Scanning...', scannedFiles, totalFiles);
                } else if (entry.kind === 'directory') {
                    const dirName = entry.name.toLowerCase();
                    if (['node_modules', '.git', 'dist', 'build', '.next', 'out', 'coverage'].includes(dirName)) {
                        continue;
                    }
                    const newPath = currentPath ? `${currentPath}/${entry.name}` : entry.name;
                    await scanDirectory(entry, newPath);
                }
            }
        }

        async function countFiles(directoryHandle) {
            let count = 0;
            for await (const entry of directoryHandle.values()) {
                if (entry.kind === 'file') {
                    count++;
                } else if (entry.kind === 'directory') {
                    const dirName = entry.name.toLowerCase();
                    if (['node_modules', '.git', 'dist', 'build', '.next', 'out', 'coverage'].includes(dirName)) {
                        continue;
                    }
                    count += await countFiles(entry);
                }
            }
            return count;
        }

        function updateProgress(label, current, total) {
            if (!total) return;
            const progress = Math.min((current / total) * 100, 100);
            progressFill.style.width = `${progress}%`;
            progressText.textContent = `${label} ${current.toLocaleString()} of ${total.toLocaleString()} files`;
        }

        async function parseSourceFiles() {
            const total = sourceFiles.length;
            if (!total) return;

            const languageCache = new Map();
            let parsedCount = 0;

            for (const file of sourceFiles) {
                const languageId = file.language;
                if (!languageId) continue;

                const extractor = getExtractorForLanguage(languageId);
                if (!extractor) continue;

                try {
                    if (!languageCache.has(languageId)) {
                        const loadedLanguage = await parserManager.loadLanguage(languageId);
                        languageCache.set(languageId, loadedLanguage);
                    }
                    const language = languageCache.get(languageId);

                    const fileHandle = fileHandles.get(file.path);
                    if (!fileHandle) continue;

                    const fileBlob = await fileHandle.getFile();
                    const source = await fileBlob.text();

                    const extracted = await extractor(source, file.path, language, languageId);

                    const annotatedFunctions = annotateFunctions(extracted.functions, languageId, file.moduleId);
                    allFunctions.push(...annotatedFunctions);
                    allCalls.push(...annotateCalls(extracted.calls, languageId));

                    const symbolTable = symbolTableManager.getTable(file.path);
                    symbolTable.setModuleId(file.moduleId);
                    symbolTableManager.registerModule(file.path, file.moduleId);

                    annotatedFunctions.forEach(func => {
                        symbolTable.registerFunction(func, { autoExport: languageId === 'python' });
                        functionMapById.set(func.id, func);
                    });

                    (extracted.exports || []).forEach(exp => {
                        if (!exp?.name) return;
                        symbolTable.addExport(exp.name, {
                            isDefault: !!exp.isDefault,
                            localName: exp.localName,
                            kind: exp.kind || 'value'
                        });
                    });

                    (extracted.imports || []).forEach(imp => {
                        if (!imp?.name) return;
                        const resolved = resolveImportModule(file, imp.from, languageId);
                        symbolTable.addImport(imp.name, {
                            from: imp.from,
                            originalName: imp.originalName,
                            isDefault: !!imp.isDefault,
                            moduleId: resolved?.moduleId || null,
                            resolvedFilePath: resolved?.filePath || null
                        });
                    });

                    parsedCount++;
                    updateProgress(`Parsing ${languageDisplayNames[languageId] || languageId}...`, parsedCount, total);
                } catch (err) {
                    console.error(`Failed to parse ${file.path}:`, err);
                }
            }
        }

        function displayResults() {
            fileList.innerHTML = '';

            sourceFiles.forEach((file, index) => {
                const { path, language } = file;
                const label = languageDisplayNames[language] || language;
                const fileFunctions = allFunctions.filter(f => f.filePath === path);

                const fileItem = document.createElement('div');
                fileItem.className = 'file-item';
                fileItem.innerHTML = `
                    <div style="font-weight: 600; margin-bottom: 0.25rem;">${path}</div>
                    <div style="font-size: 0.8rem; opacity: 0.65;">
                        ${label} · ${fileFunctions.length} function${fileFunctions.length !== 1 ? 's' : ''}
                    </div>
                `;
                fileItem.style.animationDelay = `${index * 0.02}s`;
                fileList.appendChild(fileItem);

                fileFunctions.forEach((func, funcIndex) => {
                    const funcItem = document.createElement('div');
                    funcItem.className = 'file-item';
                    funcItem.style.marginLeft = '1rem';
                    funcItem.style.marginTop = '0.5rem';
                    funcItem.style.padding = '0.5rem 0.75rem';
                    funcItem.style.fontSize = '0.85rem';
                    funcItem.innerHTML = `
                        <div style="color: #a5b4fc;">
                            <span style="font-weight: 600;">${func.name}</span>
                            <span style="opacity: 0.6; margin-left: 0.5rem;">(${func.startLine}:${func.startColumn})</span>
                        </div>
                    `;
                    funcItem.style.animationDelay = `${(index * 0.02) + (funcIndex * 0.01)}s`;
                    fileList.appendChild(funcItem);
                });
            });
        }

        async function initializeVisualization() {
            vizContainer.classList.remove('hidden');

            if (!graphViz) {
                graphViz = new GraphVisualization(vizGraph);
                await graphViz.initialize();
                graphViz.onNodeClick = handleNodeClick;
                graphViz.onNodeHover = handleNodeHover;
                graphViz.onFilterChange = applyVisualizationFilters;
            }

            if (!inspector) {
                inspector = new InspectorPanel(vizInspector);
            }

            if (!controls) {
                controls = new VisualizationControls(vizControls, graphViz);
                if (typeof controls.setEmbeddingSummary === 'function') {
                    controls.setEmbeddingSummary(latestEmbeddingSummary || null);
                }
            }

            graphViz.onHoverDetails = (info) => {
                if (controls && typeof controls.setHoverInfo === 'function') {
                    controls.setHoverInfo(info);
                }
            };

            if (inspector) {
                inspector.onNavigate = (nodeId) => {
                    graphViz.focusNodeById(nodeId);
                };
            }

            functionMapById = new Map((callGraph.nodes || []).map(fn => [fn.id, fn]));
            fullVizData = convertCallGraphToVizData(callGraph);
            const layoutKey = computeLayoutStorageKey(callGraph);
            const layoutHash = extractLayoutHash(layoutKey);
            graphViz.setLayoutStorageKey(layoutKey, layoutHash);

            if (await ensureStorageClient()) {
                const provider = createLayoutPersistenceProvider(layoutKey, layoutHash);
                graphViz.setLayoutStorageProvider(provider);
            } else {
                graphViz.setLayoutStorageProvider(null);
            }

            const initialFilters = controls ? controls.getFilters() : {};
            applyVisualizationFilters(initialFilters);

            const restored = await graphViz.restoreLayoutFromStorage({ freeze: true });
            const loadInfo = graphViz.getLastLayoutLoadResult
                ? graphViz.getLastLayoutLoadResult()
                : null;

            if (controls && typeof controls.setLayoutStatus === 'function') {
                const { message, tone, timeout } = describeLayoutStatus(loadInfo, restored);
                controls.setLayoutStatus(message, {
                    tone,
                    timeout: tone === 'success' ? undefined : timeout ?? 5000
                });
            }

            if (!restored) {
                setTimeout(() => graphViz.fitToView(), 400);
            } else {
                graphViz.fitToView();
            }
        }

        function groupFilesByLanguage(files) {
            return files.reduce((acc, file) => {
                const lang = file.language || detectLanguageFromPath(file.path || '');
                if (!acc[lang]) acc[lang] = [];
                acc[lang].push(file);
                return acc;
            }, {});
        }

        function getExtractorForLanguage(languageId) {
            switch (languageId) {
                case 'javascript':
                case 'typescript':
                case 'jsx':
                case 'tsx':
                    return extractJavaScript;
                case 'python':
                    return extractPython;
                default:
                    return null;
            }
        }

        function annotateFunctions(functions = [], languageId, moduleId = null) {
            return (functions || []).map(fn => {
                const resolvedModuleId = fn.moduleId || moduleId || null;
                return {
                    ...fn,
                    lang: fn.lang || languageId,
                    moduleId: resolvedModuleId,
                    fqName: fn.fqName || buildFunctionFqName(resolvedModuleId, fn.name)
                };
            });
        }

        function annotateCalls(calls = [], languageId) {
            return (calls || []).map(call => ({
                ...call,
                language: call.language || languageId
            }));
        }

        function getExtension(fileName = '') {
            const index = fileName.lastIndexOf('.');
            return index >= 0 ? fileName.slice(index).toLowerCase() : '';
        }

        function formatCounterMessage() {
            if (!sourceFiles.length) {
                return 'No source files processed yet';
            }

            const counts = groupFilesByLanguage(sourceFiles);
            const parts = Object.entries(counts)
                .filter(([, files]) => files.length > 0)
                .map(([lang, files]) => `${files.length} ${(languageDisplayNames[lang] || lang)} file${files.length !== 1 ? 's' : ''}`);

            return `Found ${sourceFiles.length} source file${sourceFiles.length !== 1 ? 's' : ''}${parts.length ? ' (' + parts.join(', ') + ')' : ''}`;
        }

        function convertCallGraphToVizData(graph) {
            if (!graph) return { nodes: [], links: [] };

            const nodes = (graph.nodes || []).map(fn => ({
                id: fn.id,
                fqName: fn.fqName || fn.name,
                name: fn.name,
                filePath: fn.filePath,
                lang: fn.lang || detectLanguageFromPath(fn.filePath),
                moduleId: fn.moduleId || null,
                isVirtual: !!fn.isVirtual,
                size: fn.loc || Math.max(1, (fn.endLine || fn.startLine || 0) - (fn.startLine || 0) + 1),
                startLine: fn.startLine,
                endLine: fn.endLine,
                startColumn: fn.startColumn,
                endColumn: fn.endColumn,
                doc: fn.doc || '',
                metrics: fn.metrics || {},
                source: fn.source || ''
            }));

            const links = (graph.edges || []).map(edge => {
                const metadata = edge.metadata || {};
                const resolution = metadata.resolution || null;
                const resolutionStatus = resolution?.status || 'resolved';
                return {
                    source: edge.source,
                    target: edge.target,
                    type: 'call',
                    weight: edge.weight || 1,
                    dynamic: edge.isDynamic || false,
                    resolution,
                    resolutionStatus,
                    resolutionReason: resolution?.reason || '',
                    importInfo: resolution?.importInfo || null,
                    metadata
                };
            });

            if (similarityEdges.length > 0) {
                similarityEdges.forEach(edge => {
                    links.push({
                        source: edge.source,
                        target: edge.target,
                        type: 'similarity',
                        weight: edge.similarity || edge.representativeSimilarity || 0,
                        similarity: edge.similarity || 0,
                        method: edge.method || 'topk-avg',
                        representativeSimilarity: edge.representativeSimilarity ?? null,
                        topPairs: edge.topPairs || []
                    });
                });
            }

            return { nodes, links };
        }

        function detectLanguageFromPath(path = '') {
            const ext = getExtension(path);
            switch (ext) {
                case '.ts':
                case '.tsx':
                    return 'typescript';
                case '.jsx':
                    return 'jsx';
                case '.py':
                    return 'python';
                default:
                    return 'javascript';
            }
        }

        function applyVisualizationFilters(filters = {}) {
            if (!graphViz || !fullVizData) {
                return;
            }

            const moduleFilter = filters.module?.toLowerCase() || filters.folder?.toLowerCase() || '';
            const languageFilter = filters.language || '';
            const minSize = Number.isFinite(filters.minSize) ? filters.minSize : 0;
            const maxSize = Number.isFinite(filters.maxSize) ? filters.maxSize : Infinity;

            const filteredNodes = fullVizData.nodes.filter(node => {
                if (moduleFilter && !(node.filePath || '').toLowerCase().includes(moduleFilter)) {
                    return false;
                }
                if (languageFilter && node.lang !== languageFilter) {
                    return false;
                }
                if (node.size < minSize) {
                    return false;
                }
                if (Number.isFinite(maxSize) && node.size > maxSize) {
                    return false;
                }
                return true;
            });

            const allowedIds = new Set(filteredNodes.map(node => node.id));
            const filteredLinks = fullVizData.links.filter(link => allowedIds.has(link.source) && allowedIds.has(link.target));

            graphViz.loadData({ nodes: filteredNodes, links: filteredLinks });
        }

        async function handleNodeClick(node, edgeSummary) {
            if (!node) {
                inspector?.hide();
                return;
            }
            const source = await getFunctionSource(node);
            inspector?.show(node, source, edgeSummary);
        }

        function handleNodeHover(node) {
            // Future enhancements: display hover details in sidebar
        }

        async function getFunctionSource(node) {
            const original = functionMapById.get(node.id);
            if (original?.source) {
                return original.source;
            }

            const filePath = original?.filePath || node.filePath;
            if (!filePath || !fileHandles.has(filePath)) {
                return '';
            }

            try {
                const fileHandle = fileHandles.get(filePath);
                const file = await fileHandle.getFile();
                const source = await file.text();
                if (original?.startLine && original?.endLine) {
                    const lines = source.split('\n');
                    const slice = lines.slice(original.startLine - 1, original.endLine).join('\n');
                    return slice;
                }
                return source;
            } catch (err) {
                console.error('Failed to read function source', err);
                return '';
            }
        }

        function buildFunctionFqName(moduleId, name) {
            if (!name) {
                return name;
            }
            if (!moduleId) {
                return name;
            }
            return `${moduleId}.${name}`;
        }

        function registerSourceFile(fileMeta) {
            if (!fileMeta || !fileMeta.path) {
                return;
            }

            const normalized = {
                ...fileMeta,
                path: normalizeSlashes(fileMeta.path)
            };

            sourceFileIndex.set(normalized.path, normalized);

            if (normalized.moduleId) {
                const entry = ensureModuleIndexEntry(normalized.moduleId);
                entry.files.add(normalized.path);
                (normalized.moduleAliases || []).forEach(alias => {
                    if (alias) {
                        entry.aliases.add(alias);
                    }
                });
            }
        }

        function ensureModuleIndexEntry(moduleId) {
            if (!moduleId) {
                return { files: new Set(), aliases: new Set() };
            }
            if (!moduleIndex.has(moduleId)) {
                moduleIndex.set(moduleId, { files: new Set(), aliases: new Set([moduleId]) });
            }
            return moduleIndex.get(moduleId);
        }

        function createModuleMetadata(filePath, languageId) {
            const normalizedPath = normalizeSlashes(filePath);
            const fileName = normalizedPath.split('/').pop() || '';
            const dirName = getDirname(normalizedPath);
            const lowerFileName = fileName.toLowerCase();
            const aliases = new Set();

            let moduleId = stripExtension(normalizedPath);
            const isJavaScriptLike = ['javascript', 'typescript', 'jsx', 'tsx'].includes(languageId);

            if (isJavaScriptLike) {
                if (JS_INDEX_FILENAMES.includes(lowerFileName)) {
                    moduleId = dirName || moduleId;
                }
                aliases.add(normalizeSlashes(moduleId));
                aliases.add(stripExtension(fileName));
            } else if (languageId === 'python') {
                if (PY_PACKAGE_FILENAMES.includes(lowerFileName)) {
                    moduleId = dirName;
                }
                const dotted = (moduleId || '').replace(/\//g, '.').replace(/^\.+/, '');
                const packageAlias = (dirName || '').replace(/\//g, '.').replace(/^\.+/, '');
                if (dotted) aliases.add(dotted);
                if (packageAlias) aliases.add(packageAlias);
                if (moduleId) aliases.add(moduleId);
            } else {
                aliases.add(moduleId);
            }

            const aliasList = Array.from(aliases).filter(Boolean);

            return {
                moduleId: moduleId || normalizedPath,
                aliases: aliasList
            };
        }

        function normalizeSlashes(path = '') {
            return path.replace(/\\/g, '/');
        }

        function stripExtension(path = '') {
            const normalized = normalizeSlashes(path);
            const lastDot = normalized.lastIndexOf('.');
            if (lastDot <= normalized.lastIndexOf('/')) {
                return normalized;
            }
            return normalized.slice(0, lastDot);
        }

        function getDirname(path = '') {
            const normalized = normalizeSlashes(path);
            const idx = normalized.lastIndexOf('/');
            if (idx === -1) {
                return '';
            }
            return normalized.slice(0, idx);
        }

        function resolveRelativePath(fromPath, specifier) {
            const fromDir = getDirname(fromPath);
            const segments = fromDir ? fromDir.split('/') : [];
            const specSegments = normalizeSlashes(specifier).split('/');

            for (const segment of specSegments) {
                if (!segment || segment === '.') {
                    continue;
                }
                if (segment === '..') {
                    if (segments.length) {
                        segments.pop();
                    }
                } else {
                    segments.push(segment);
                }
            }

            return segments.join('/');
        }

        function enumeratePossibleModuleFiles(basePath, languageId) {
            const possibilities = [];
            const baseWithoutExt = stripExtension(basePath);

            if (['javascript', 'typescript', 'jsx', 'tsx'].includes(languageId)) {
                JS_FILE_EXTENSIONS.forEach(ext => {
                    possibilities.push(`${baseWithoutExt}${ext}`);
                });
                JS_FILE_EXTENSIONS.forEach(ext => {
                    possibilities.push(`${baseWithoutExt}/index${ext}`);
                });
            } else if (languageId === 'python') {
                possibilities.push(`${baseWithoutExt}.py`);
                possibilities.push(`${baseWithoutExt}/__init__.py`);
            } else {
                possibilities.push(basePath);
            }

            return Array.from(new Set(possibilities.map(normalizeSlashes)));
        }

        function resolveImportModule(fileMeta, specifier, languageId) {
            if (!specifier) {
                return null;
            }

            const normalizedSpec = normalizeSlashes(specifier);

            const trySourceFile = (candidatePath) => {
                const meta = sourceFileIndex.get(candidatePath);
                if (meta) {
                    return {
                        moduleId: meta.moduleId || null,
                        filePath: meta.path
                    };
                }
                return null;
            };

            if (normalizedSpec.startsWith('.')) {
                const basePath = resolveRelativePath(fileMeta.path, normalizedSpec);
                const candidates = enumeratePossibleModuleFiles(basePath, languageId);
                for (const candidate of candidates) {
                    const resolved = trySourceFile(candidate);
                    if (resolved) {
                        return resolved;
                    }
                }
            } else {
                for (const [moduleId, entry] of moduleIndex.entries()) {
                    if (moduleId === normalizedSpec || entry.aliases.has(normalizedSpec)) {
                        const files = Array.from(entry.files);
                        if (files.length) {
                            return {
                                moduleId,
                                filePath: files[0]
                            };
                        }
                    }
                }

                if (languageId === 'python') {
                    const candidateBase = normalizedSpec.replace(/\./g, '/');
                    const candidates = enumeratePossibleModuleFiles(candidateBase, languageId);
                    for (const candidate of candidates) {
                        const resolved = trySourceFile(candidate);
                        if (resolved) {
                            return resolved;
                        }
                    }
                }
            }

            return null;
        }

        async function ensureStorageClient() {
            if (storageReady && storageClient) {
                return true;
            }
            if (storageClientInitPromise) {
                return storageClientInitPromise;
            }
            storageClientInitPromise = (async () => {
                try {
                    const client = new StorageWorkerClient();
                    await client.ensureInitialized();
                    storageClient = client;
                    storageReady = true;
                    return true;
                } catch (err) {
                    console.warn('Storage worker unavailable; falling back to browser storage.', err);
                    storageClient = null;
                    storageReady = false;
                    return false;
                } finally {
                    storageClientInitPromise = null;
                }
            })();
            return storageClientInitPromise;
        }

        async function initializeResumeOption() {
            if (!resumeBtn) {
                return;
            }
            resumeBtn.classList.add('hidden');
            resumeSnapshot = null;
            try {
                const available = await ensureStorageClient();
                if (!available || !storageClient) {
                    return;
                }
                const snapshot = await loadAnalysisSnapshot(storageClient);
                if (snapshot && Array.isArray(snapshot.callGraph?.nodes) && snapshot.callGraph.nodes.length) {
                    resumeSnapshot = snapshot;
                    resumeBtn.classList.remove('hidden');
                }
            } catch (err) {
                console.warn('Failed to load resume snapshot:', err);
            }
        }

        async function hydrateFromSnapshot(snapshot) {
            if (!snapshot || !snapshot.callGraph) {
                return;
            }

            sourceFiles = Array.isArray(snapshot.sourceFiles)
                ? snapshot.sourceFiles.map(file => ({
                    path: file.path || '',
                    language: file.language || null,
                    moduleId: file.moduleId || null,
                    moduleAliases: Array.isArray(file.moduleAliases) ? [...file.moduleAliases] : []
                }))
                : [];
            fileHandles.clear();
            sourceFileIndex.clear();
            moduleIndex.clear();
            sourceFiles.forEach(registerSourceFile);

            allFunctions = Array.isArray(snapshot.functions)
                ? snapshot.functions.map(fn => ({ ...fn }))
                : [];
            allCalls = [];

            const callGraphNodes = Array.isArray(snapshot.callGraph?.nodes)
                ? snapshot.callGraph.nodes.map(node => ({ ...node }))
                : [];
            const callGraphEdges = Array.isArray(snapshot.callGraph?.edges)
                ? snapshot.callGraph.edges.map(edge => ({
                    ...edge,
                    metadata: edge.metadata ? { ...edge.metadata } : null
                }))
                : [];
            callGraph = {
                nodes: callGraphNodes,
                edges: callGraphEdges,
                stats: snapshot.callGraph?.stats || {
                    totalEdges: callGraphEdges.length,
                    staticEdges: 0,
                    dynamicEdges: 0,
                    resolvedEdges: 0,
                    ambiguousEdges: 0,
                    unresolvedEdges: 0
                }
            };

            similarityEdges = Array.isArray(snapshot.similarityEdges)
                ? snapshot.similarityEdges.map(edge => ({ ...edge }))
                : [];

            embeddingMetadata = snapshot.embedding?.metadata
                ? { ...snapshot.embedding.metadata }
                : {
                    backend: null,
                    modelId: null,
                    dimension: null,
                    quantized: null
                };
            embeddingReuseCounts = snapshot.embedding?.reuse
                ? { ...snapshot.embedding.reuse }
                : { reused: 0, embedded: 0 };
            embeddingStats = snapshot.embedding?.stats || null;
            usedCachedEmbeddings = !!snapshot.embedding?.cached;
            embeddingFingerprint = snapshot.fingerprint || null;
            latestFunctionFingerprintMap = snapshot.functionFingerprints || null;
            embeddingError = snapshot.embedding?.error || null;

            embeddingChunks = [];
            embeddingVectors = [];
            functionEmbeddings = [];

            window.heliosFunctions = allFunctions;
            window.heliosCallGraph = callGraph;
            window.heliosSimilarity = similarityEdges;
            window.heliosEmbeddingReuse = embeddingReuseCounts;
            window.heliosEmbeddingStats = embeddingStats;
            window.heliosEmbeddingError = embeddingError;

            updateEmbeddingSummary({
                chunkCount: snapshot.embedding?.chunkCount ?? null,
                metadata: embeddingMetadata,
                reuse: embeddingReuseCounts,
                cached: usedCachedEmbeddings,
                similarityEdges: similarityEdges.length,
                functionsWithEmbeddings: allFunctions.length,
                error: embeddingError
            });

            totalFiles = sourceFiles.length;
            scannedFiles = totalFiles;
            counter.textContent = formatCounterMessage();

            const stats = snapshot.stats || {};
            const graphStats = stats.callGraphStats || callGraph.stats || {};
            const totalEdges = graphStats.totalEdges ?? callGraph.edges.length;
            const staticEdges = graphStats.staticEdges ?? 0;
            const dynamicEdges = graphStats.dynamicEdges ?? 0;
            const resolvedEdges = graphStats.resolvedEdges ?? 0;
            const ambiguousEdges = graphStats.ambiguousEdges ?? 0;
            const unresolvedEdges = graphStats.unresolvedEdges ?? 0;

            const resolutionDetails = [];
            if (resolvedEdges) resolutionDetails.push(`${resolvedEdges} resolved`);
            if (ambiguousEdges) resolutionDetails.push(`${ambiguousEdges} ambiguous`);
            if (unresolvedEdges) resolutionDetails.push(`${unresolvedEdges} unresolved`);
            const resolutionSummary = resolutionDetails.length ? ` · ${resolutionDetails.join(' / ')}` : '';

            let embeddingSummary = '';
            if (embeddingMetadata && (embeddingMetadata.modelId || embeddingMetadata.dimension)) {
                const dim = embeddingMetadata.dimension ? `${embeddingMetadata.dimension}-dim` : 'unknown-dim';
                const backendLabel = embeddingMetadata.backend ? embeddingMetadata.backend.toUpperCase() : 'WASM';
                let reuseLabel = '';
                if (usedCachedEmbeddings) {
                    reuseLabel = ', cached';
                } else if ((embeddingReuseCounts.reused || 0) > 0 || (embeddingReuseCounts.embedded || 0) > 0) {
                    const reusedLabel = `${(embeddingReuseCounts.reused || 0).toLocaleString()} reused`;
                    const embeddedLabel = (embeddingReuseCounts.embedded || 0) > 0
                        ? ` / ${(embeddingReuseCounts.embedded || 0).toLocaleString()} new`
                        : '';
                    reuseLabel = `, ${reusedLabel}${embeddedLabel}`;
                }
                const chunkCount = snapshot.embedding?.chunkCount ?? null;
                const chunkLabel = Number.isFinite(chunkCount)
                    ? `${chunkCount.toLocaleString()} embedding chunk${chunkCount !== 1 ? 's' : ''}`
                    : 'embeddings cached';
                embeddingSummary = ` · ${chunkLabel} (${dim}, ${backendLabel}${reuseLabel})`;
            } else if (embeddingError) {
                embeddingSummary = ' · Embeddings failed previously';
            }

            let similaritySummary = '';
            if (similarityEdges.length > 0) {
                similaritySummary = ` · ${similarityEdges.length.toLocaleString()} similarity edge${similarityEdges.length !== 1 ? 's' : ''}`;
            }

            const functionCount = stats.functionCount ?? allFunctions.length;
            functionsCounter.textContent = `${functionCount.toLocaleString()} function${functionCount !== 1 ? 's' : ''} cached · ${totalEdges.toLocaleString()} call edge${totalEdges !== 1 ? 's' : ''} (${staticEdges.toLocaleString()} static · ${dynamicEdges.toLocaleString()} dynamic)${resolutionSummary}${embeddingSummary}${similaritySummary}`;

            displayResults();
            progressContainer.classList.add('hidden');
            resultsContainer.classList.remove('hidden');
            visualizeBtn.classList.remove('hidden');

            resumeSnapshot = snapshot;
            await initializeVisualization();
        }

        function createLayoutPersistenceProvider(layoutKey, layoutHash) {
            if (!storageReady || !storageClient) {
                return null;
            }
            return {
                async save({ key, snapshot, metadata }) {
                    await saveLayoutSnapshot(storageClient, {
                        graphKey: key,
                        graphHash: layoutHash,
                        snapshot,
                        metadata: {
                            ...(metadata || {}),
                            graphKey: key,
                            graphHash: layoutHash
                        }
                    });
                },
                async load({ key }) {
                    return loadLayoutSnapshot(storageClient, key);
                },
                async delete({ key }) {
                    await deleteLayoutSnapshot(storageClient, key);
                },
                async has({ key }) {
                    const response = await listLayoutSnapshots(storageClient, { graphKey: key, limit: 1 });
                    return Array.isArray(response?.snapshots) && response.snapshots.length > 0;
                }
            };
        }

        function describeLayoutStatus(loadInfo, restored) {
            const target = storageReady ? 'OPFS storage' : 'browser storage';
            if (restored) {
                return { message: `Layout restored from ${target}.`, tone: 'success', timeout: undefined };
            }
            switch (loadInfo?.status) {
                case 'mismatch':
                    return { message: 'Saved layout found but incompatible with current graph.', tone: 'error', timeout: 5000 };
                case 'error':
                    return { message: 'Unable to load saved layout.', tone: 'error', timeout: 5000 };
                case 'ok':
                case 'ok-local':
                    return { message: 'Saved layout found but could not be applied.', tone: 'error', timeout: 5000 };
                default:
                    return { message: 'Layout will auto-save when you choose “Save Layout”.', tone: 'info', timeout: 5000 };
            }
        }

        function extractLayoutHash(layoutKey = '') {
            if (typeof layoutKey !== 'string') {
                return null;
            }
            const parts = layoutKey.split(':');
            return parts.length ? parts[parts.length - 1] || null : null;
        }

        function computeLayoutStorageKey(graph) {
            const prefix = 'helios:v1:layout';
            if (!graph || !Array.isArray(graph.nodes)) {
                return `${prefix}:default`;
            }

            const nodeCount = graph.nodes.length;
            const edgeCount = Array.isArray(graph.edges) ? graph.edges.length : 0;
            const signatureSample = (graph.nodes || [])
                .slice(0, 64)
                .map(node => node.id || node.fqName || node.name || '')
                .sort()
                .join('|');

            const hash = hashString(`${nodeCount}:${edgeCount}:${signatureSample}`);
            return `${prefix}:${hash}`;
        }

        function hashString(value = '') {
            let hash = 0;
            for (let i = 0; i < value.length; i += 1) {
                hash = ((hash << 5) - hash) + value.charCodeAt(i);
                hash |= 0;
            }
            return Math.abs(hash).toString(16);
        }

        initializeResumeOption().catch(err => {
            console.warn('Resume snapshot init failed:', err);
        });
    </script>
</body>
</html>
